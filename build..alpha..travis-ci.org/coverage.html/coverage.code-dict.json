{"/home/travis/build/npmtest/node-npmtest-raptor-templates/test.js":"/* istanbul instrument in package npmtest_raptor_templates */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-raptor-templates/lib.npmtest_raptor_templates.js":"/* istanbul instrument in package npmtest_raptor_templates */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_raptor_templates = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_raptor_templates = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-raptor-templates/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-raptor-templates && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_raptor_templates */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_raptor_templates\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_raptor_templates.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_raptor_templates.rollup.js'] =\n            local.assetsDict['/assets.npmtest_raptor_templates.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_raptor_templates.__dirname + '/lib.npmtest_raptor_templates.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-raptor-templates/node_modules/raptor-templates/runtime/raptor-templates-runtime.js":"/*\n * Copyright 2011 eBay Software Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * This module provides the runtime for rendering compiled templates.\n *\n *\n * <p>The code for the Raptor Templates compiler is kept separately\n * in the {@link raptor/templating/compiler} module.\n */\nvar renderContext = require('raptor-render-context');\nvar Context = renderContext.Context;\nvar helpers = require('./helpers');\nvar loader = require('./loader');\nvar cache = {};\nvar Readable;\n\nexports.Context = Context;\n\n\nvar stream;\nvar STREAM = 'stream';\n\nvar streamPath;\ntry {\n    streamPath = require.resolve(STREAM);\n} catch(e) {}\n\nif (streamPath) {\n    stream = require(streamPath);\n}\n\n\nfunction renderWithCallback(template, data, context, callback) {\n    context\n        .on('end', function() {\n            callback(null, context.getOutput());\n        })\n        .on('error', callback);\n\n    template._(data, context);    //Invoke the template rendering function with the required arguments\n\n    context.end();\n}\n\nfunction Template(renderFunc) {\n    this._ = renderFunc;\n}\n\nTemplate.prototype = {\n    renderSync: function(data) {\n        var context = new Context();\n        context.sync();\n        this._(data, context);\n        context.end();\n        return context.getOutput();\n    },\n    render: function(data, context, callback) {\n        if (data == null) {\n            data = {};\n        }\n\n        // callback is last argument if provided\n        callback = arguments[arguments.length - 1];\n        if (typeof callback === 'function') {\n            if (arguments.length === 2) { // data, context, callback\n                callback = context;\n                context = new Context();\n            }\n            renderWithCallback(this, data, context, callback);\n        } else {\n            if (context.isRenderContext) {\n                this._(data, context);\n            } else {\n                // Assume the \"context\" is really a stream\n                context = new Context(context);\n                this._(data, context);\n                context.end(); // End the context and the underlying stream\n            }\n        }\n\n        return context;\n    },\n    stream: function(data) {\n        if (!stream) {\n            return function() {\n                throw new Error('Module not found: stream');\n            };\n        }\n\n        return new Readable(this, data);\n    }\n};\n\nif (stream) {\n    Readable = function(template, data) {\n        Readable.$super.call(this);\n        this._t = template;\n        this._d = data;\n        this._rendered = false;\n    };\n\n    Readable.prototype = {\n        write: function(data) {\n            if (data != null) {\n                this.push(data);\n            }\n        },\n        end: function() {\n            this.push(null);\n        },\n        _read: function() {\n            if (this._rendered) {\n                return;\n            }\n\n            this._rendered = true;\n\n            var template = this._t;\n            var data = this._d;\n\n            var context = exports.createContext(this);\n            template.render(data, context);\n            context.end();\n        }\n    };\n\n    require('raptor-util/inherit')(Readable, stream.Readable);\n}\n\nfunction load(templatePath) {\n    var template;\n\n    if (typeof templatePath === 'string') {\n        template = cache[templatePath];\n        if (!template) {\n            template = cache[templatePath] = new Template(loader(templatePath)(helpers));\n        }\n    } else {\n        // Instead of a path, assume we got a compiled template module\n        template = templatePath._ || (templatePath._ = new Template(templatePath(helpers)));\n    }\n\n    return template;\n}\n\nexports.load = load;\n\nexports.render = function (templatePath, data, context) {\n    return load(templatePath).render(data, context);\n};\n\nexports.stream = function(templatePath, data) {\n    return load(templatePath).stream(data);\n};\n\nexports.unload = function(templatePath) {\n    delete cache[templatePath];\n};\n\nexports.createContext = function(writer) {\n    return new Context(writer);\n};\n\nexports.helpers = helpers;\n","/home/travis/build/npmtest/node-npmtest-raptor-templates/node_modules/raptor-templates/runtime/helpers.js":"var escapeXml = require('raptor-util/escapeXml');\nvar escapeXmlAttr = escapeXml.attr;\nvar runtime = require('./'); // Circular dependnecy, but that is okay\nvar extend = require('raptor-util/extend');\nvar attr = require('raptor-util/attr');\nvar attrs = require('raptor-util/attrs');\nvar forEach = require('raptor-util/forEach');\n\nfunction notEmpty(o) {\n    if (Array.isArray(o) === true) {\n        return o.length !== 0;\n    }\n    return o;\n}\n\nmodule.exports = {\n    s: function(str) {\n        return (str == null) ? '' : str;\n    },\n\n    fv: function (array, callback) {\n        if (!array) {\n            return;\n        }\n        if (!array.forEach) {\n            array = [array];\n        }\n        var i = 0;\n        var len = array.length;\n        var loopStatus = {\n                getLength: function () {\n                    return len;\n                },\n                isLast: function () {\n                    return i === len - 1;\n                },\n                isFirst: function () {\n                    return i === 0;\n                },\n                getIndex: function () {\n                    return i;\n                }\n            };\n        for (; i < len; i++) {\n            var o = array[i];\n            callback(o || '', loopStatus);\n        }\n    },\n    f: forEach,\n    fl: function (array, func) {\n        if (array != null) {\n            if (!Array.isArray(array)) {\n                array = [array];\n            }\n            func(array, 0, array.length);\n        }\n    },\n    fp: function (o, func) {\n        if (!o) {\n            return;\n        }\n        for (var k in o) {\n            if (o.hasOwnProperty(k)) {\n                func(k, o[k]);\n            }\n        }\n    },\n    e: function (o) {\n        return !notEmpty(o);\n    },\n    ne: notEmpty,\n    x: escapeXml,\n    xa: escapeXmlAttr,\n    nx: function (str) {\n        return {\n            toString: function () {\n                return str;\n            }\n        };\n    },\n    a: attr,\n\n    as: attrs,\n    l: function(path) {\n        return typeof path === 'string' ? runtime.load(path) : path;\n    },\n\n    /* Helpers that require a context below: */\n\n    t: function (context, handler, props, body) {\n        if (!props) {\n            props = {};\n        }\n\n        if (body) {\n            props.invokeBody = body;\n        }\n\n        var func;\n\n        if (!(func = handler.process || handler.render)) {\n            if (typeof handler === 'function') {\n                func = handler;\n            } else {\n                throw new Error('Invalid handler: ' + handler);\n            }\n        }\n\n        func.call(handler, props, context);\n    },\n    c: function (context, func) {\n        var output = context.captureString(func);\n        return {\n            toString: function () {\n                return output;\n            }\n        };\n    },\n    i: function(context, path, data) {\n        if (!path) {\n            return;\n        }\n\n        if (typeof path === 'string') {\n            runtime.render(path, data, context);\n        } else if (typeof path.render === 'function') {\n            path.render(data, context);\n        } else {\n            throw new Error('Invalid template');\n        }\n\n        return this;\n    },\n    xt: extend\n};\n","/home/travis/build/npmtest/node-npmtest-raptor-templates/node_modules/raptor-templates/runtime/loader.js":"var nodePath = require('path');\nvar fs = require('fs');\nvar Module = require('module').Module;\nvar raptorTemplatesCompiler = require('../compiler');\nvar cwd = process.cwd();\n\nfunction loadSource(templatePath, compiledSrc) {\n    var templateModulePath = templatePath + '.js';\n\n    var templateModule = new Module(templateModulePath, module);\n    templateModule.paths = Module._nodeModulePaths(nodePath.dirname(templateModulePath));\n    templateModule.filename = templateModulePath;\n\n\n    templateModule._compile(\n        compiledSrc,\n        templateModulePath);\n\n    return templateModule.exports;\n}\n\nmodule.exports = function load(templatePath) {\n    templatePath = nodePath.resolve(cwd, templatePath);\n\n    var targetFile = templatePath + '.js';\n    var compiler = raptorTemplatesCompiler.createCompiler(templatePath);\n    var isUpToDate = compiler.checkUpToDate(targetFile);\n    if (isUpToDate) {\n        return require(targetFile);\n    }\n\n\tvar templateSrc = fs.readFileSync(templatePath, {encoding: 'utf8'});\n\tvar compiledSrc = compiler.compile(templateSrc);\n\n    // console.log('Compiled code for \"' + templatePath + '\":\\n' + compiledSrc);\n\n    fs.writeFileSync(targetFile, compiledSrc, {encoding: 'utf8'});\n\n    return require(targetFile);\n};\n\nmodule.exports.loadSource = loadSource;\n","/home/travis/build/npmtest/node-npmtest-raptor-templates/node_modules/raptor-templates/compiler/raptor-templates-compiler.js":"/*\n * Copyright 2011 eBay Software Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n'use strict';\nvar extend = require('raptor-util').extend;\nvar fs = require('fs');\nvar nodePath = require('path');\n\nvar defaultOptions = {\n        minify: false,\n        preserveWhitespace: {\n            'pre': true,\n            'textarea': true,\n            'script': true\n        },\n        allowSelfClosing: {},\n        startTagOnly: {\n            'img': true,\n            'br': true,\n            'input': true,\n            'meta': true,\n            'link': true,\n            'hr': true\n        },\n        checkUpToDate: true\n    };\n\nextend(exports, {\n    createCompiler: function (path, options) {\n        var TemplateCompiler = require('./TemplateCompiler');\n        //Get a reference to the TemplateCompiler class\n        if (options) {\n            /*\n             * If options were provided then they should override the default options.\n             * NOTE: Only top-level properties are overridden\n             */\n            options = extend(extend({}, defaultOptions), options);\n        } else {\n            options = defaultOptions;    //Otherwise, no options were provided so use the default options\n        }\n\n        return new TemplateCompiler(path, options);\n    },\n\n    compile: function (src, path, options, callback) {\n        if (typeof options === 'function') {\n            callback = options;\n            options = undefined;\n        }\n\n        return this.createCompiler(path, options).compile(src, callback);\n    },\n\n    compileFile: function(path, options, callback) {\n        if (typeof options === 'function') {\n            callback = options;\n            options = null;\n        }\n\n        var compiler = this.createCompiler(path, options);\n\n        fs.readFile(path, {encoding: 'utf8'}, function(err, src) {\n            if (err) {\n                return callback(err);\n            }\n\n            try {\n                callback(null, compiler.compile(src));\n            } catch(e) {\n                callback(e);\n            }\n        });\n    },\n\n    getLastModified: function(path, options, callback) {\n        if (typeof options === 'function') {\n            callback = options;\n            options = null;\n        }\n\n        var compiler = this.createCompiler(path, options);\n        callback(null, compiler.getLastModified());\n    },\n\n    Node: require('./Node'),\n    ElementNode: require('./ElementNode'),\n    TextNode: require('./TextNode'),\n    expressionParser: require('./expression-parser'),\n    Expression: require('./Expression'),\n    TypeConverter: require('./TypeConverter'),\n    EscapeXmlContext: require('./EscapeXmlContext'),\n    defaultOptions: defaultOptions\n});\n\nexports.TemplateCompiler = require('./TemplateCompiler');\nexports.taglibs = require('./taglibs');\nexports.taglibs.excludeDir(nodePath.join(__dirname, '../'));\n\nexports.taglibs.registerTaglib(require.resolve('../taglibs/core/raptor-taglib.json'));\nexports.taglibs.registerTaglib(require.resolve('../taglibs/html/raptor-taglib.json'));\nexports.taglibs.registerTaglib(require.resolve('../taglibs/caching/raptor-taglib.json'));\nexports.taglibs.registerTaglib(require.resolve('raptor-taglib-layout/raptor-taglib.json'));\nexports.taglibs.registerTaglib(require.resolve('raptor-taglib-async/raptor-taglib.json'));\n","/home/travis/build/npmtest/node-npmtest-raptor-templates/node_modules/raptor-templates/compiler/Node.js":"/*\n * Copyright 2011 eBay Software Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n'use strict';\nvar createError = require('raptor-util').createError;\nvar forEachEntry = require('raptor-util').forEachEntry;\nvar extend = require('raptor-util').extend;\nvar isArray = Array.isArray;\nvar EscapeXmlContext = require('./EscapeXmlContext');\n\nfunction Node(nodeType) {\n    if (!this.nodeType) {\n        this._isRoot = false;\n        this.preserveWhitespace = null;\n        this.wordWrapEnabled = null;\n        this.escapeXmlBodyText = null;\n        this.escapeXmlContext = null;\n        this.nodeType = nodeType;\n        this.parentNode = null;\n        this.previousSibling = null;\n        this.nextSibling = null;\n        this.firstChild = null;\n        this.lastChild = null;\n        this.namespaceMappings = {};\n        this.prefixMappings = {};\n        this.transformersApplied = {};\n        this.properties = {};\n        this.beforeCode = [];\n        this.afterCode = [];\n        this.data = {}; // Property for associating arbitrary data with a node\n    }\n}\n\nNode.isNode = function(node) {\n    return node.__NODE === true;\n};\n\nNode.prototype = {\n\n    setRoot: function (isRoot) {\n        this._isRoot = isRoot;\n    },\n    getPosition: function () {\n        var pos = this.pos || this.getProperty('pos') || {\n                toString: function () {\n                    return '(unknown position)';\n                }\n            };\n        return pos;\n    },\n    setPosition: function (pos) {\n        this.pos = pos;\n    },\n    addError: function (error) {\n        var compiler = this.compiler;\n        var curNode = this;\n        while (curNode != null && !compiler) {\n            compiler = curNode.compiler;\n            if (compiler) {\n                break;\n            }\n            curNode = curNode.parentNode;\n        }\n        if (!compiler) {\n            throw createError(new Error('Template compiler not set for node ' + this));\n        }\n        var pos = this.getPosition();\n        compiler.addError(error + ' (' + this.toString() + ')', pos);\n    },\n    resolveNamespace: function(namespace) {\n        return namespace || '';\n    },\n    setProperty: function (name, value) {\n        this.properties[name] = value;\n    },\n    setProperties: function (props) {\n        if (!props) {\n            return;\n        }\n        extend(this.properties, props);\n    },\n    getProperties: function () {\n        return this.properties;\n    },\n    hasProperty: function (name) {\n        return this.properties.hasOwnProperty(name);\n    },\n    forEachProperty: function (callback, thisObj) {\n        forEachEntry(this.properties, callback, this);\n    },\n    getProperty: function (name) {\n        return this.properties[name];\n    },\n    removeProperty: function (name) {\n        delete this.properties[name];\n    },\n    forEachChild: function (callback, thisObj) {\n        if (!this.firstChild) {\n            return;\n        }\n        var children = [];\n        var curChild = this.firstChild;\n        while (curChild) {\n            children.push(curChild);\n            curChild = curChild.nextSibling;\n        }\n        for (var i = 0, len = children.length; i < len; i++) {\n            curChild = children[i];\n            if (curChild.parentNode === this) {\n                //Make sure the node is still a child of this node\n                if (false === callback.call(thisObj, curChild)) {\n                    return;\n                }\n            }\n        }\n    },\n    getExpression: function (template, childrenOnly, escapeXml, asFunction) {\n        if (!template) {\n            throw createError(new Error('template argument is required'));\n        }\n        var _this = this;\n\n        var methodCall;\n\n        if (escapeXml !== false) {\n            methodCall = 'context.captureString(';\n        } else {\n            methodCall = '__helpers.c(context, ';\n        }\n\n        return template.makeExpression({\n            toString: function () {\n                return template.captureCode(function () {\n                    if (asFunction) {\n                        template.code('function() {\\n').code(template.indentStr(2) + 'return ' + methodCall + 'function() {\\n').indent(3, function () {\n                            if (childrenOnly === true) {\n                                _this.generateCodeForChildren(template);\n                            } else {\n                                _this.generateCode(template);\n                            }\n                        }).code(template.indentStr(2) + '});\\n').code(template.indentStr() + '}');\n                    } else {\n                        template.code(methodCall + 'function() {\\n').indent(function () {\n                            if (childrenOnly === true) {\n                                _this.generateCodeForChildren(template);\n                            } else {\n                                _this.generateCode(template);\n                            }\n                        }).code(template.indentStr() + '})');\n                    }\n                });\n            }\n        });\n    },\n    getBodyContentExpression: function (template, escapeXml) {\n        return this.getExpression(template, true, escapeXml, false);\n    },\n    getBodyContentFunctionExpression: function (template, escapeXml) {\n        return this.getExpression(template, true, escapeXml, true);\n    },\n    isTransformerApplied: function (transformer) {\n        return this.transformersApplied[transformer.id] === true;\n    },\n    setTransformerApplied: function (transformer) {\n        this.transformersApplied[transformer.id] = true;\n    },\n    hasChildren: function () {\n        return this.firstChild != null;\n    },\n    appendChild: function (childNode) {\n        if (childNode.parentNode) {\n            childNode.parentNode.removeChild(childNode);\n        }\n        if (!this.firstChild) {\n            this.firstChild = this.lastChild = childNode;\n            childNode.nextSibling = null;\n            childNode.previousSibling = null;\n        } else {\n            this.lastChild.nextSibling = childNode;\n            childNode.previousSibling = this.lastChild;\n            this.lastChild = childNode;\n        }\n        childNode.parentNode = this;\n    },\n    appendChildren: function (childNodes) {\n        if (!childNodes) {\n            return;\n        }\n        childNodes.forEach(function (childNode) {\n            this.appendChild(childNode);\n        }, this);\n    },\n    isRoot: function () {\n        return this._isRoot === true;\n    },\n    detach: function () {\n        if (this.parentNode) {\n            this.parentNode.removeChild(this);\n        }\n    },\n    removeChild: function (childNode) {\n        if (childNode.parentNode !== this) {\n            //Check if the child node is a child of the parent\n            return null;\n        }\n        var previousSibling = childNode.previousSibling;\n        var nextSibling = childNode.nextSibling;\n        if (this.firstChild === childNode && this.lastChild === childNode) {\n            //The child node is the one and only child node being removed\n            this.firstChild = this.lastChild = null;\n        } else if (this.firstChild === childNode) {\n            //The child node being removed is the first child and there is another child after it\n            this.firstChild = this.firstChild.nextSibling;\n            //Make the next child the first child\n            this.firstChild.previousSibling = null;\n        } else if (this.lastChild === childNode) {\n            //The child node being removed is the last child and there is another child before it\n            this.lastChild = this.lastChild.previousSibling;\n            //Make the previous child the last child\n            this.lastChild.nextSibling = null;\n        } else {\n            previousSibling.nextSibling = nextSibling;\n            nextSibling.previousSibling = previousSibling;\n        }\n        //Make sure the removed node is completely detached\n        childNode.parentNode = null;\n        childNode.previousSibling = null;\n        childNode.nextSibling = null;\n        return childNode;\n    },\n    removeChildren: function () {\n        while (this.firstChild) {\n            this.removeChild(this.firstChild);\n        }\n    },\n    replaceChild: function (newChild, replacedChild) {\n        if (newChild === replacedChild) {\n            return false;\n        }\n        if (!replacedChild) {\n            return false;\n        }\n        if (replacedChild.parentNode !== this) {\n            return false;    //The parent does not have the replacedChild as a child... nothing to do\n        }\n        if (this.firstChild === replacedChild && this.lastChild === replacedChild) {\n            this.firstChild = newChild;\n            this.lastChild = newChild;\n            newChild.previousSibling = null;\n            newChild.nextSibling = null;\n        } else if (this.firstChild === replacedChild) {\n            newChild.nextSibling = replacedChild.nextSibling;\n            replacedChild.nextSibling.previousSibling = newChild;\n            this.firstChild = newChild;\n        } else if (this.lastChild === replacedChild) {\n            newChild.previousSibling = replacedChild.previousSibling;\n            newChild.nextSibling = null;\n            replacedChild.previousSibling.nextSibling = newChild;\n            this.lastChild = newChild;\n        } else {\n            replacedChild.nextSibling.previousSibling = newChild;\n            replacedChild.previousSibling.nextSibling = newChild;\n            newChild.nextSibling = replacedChild.nextSibling;\n            newChild.previousSibling = replacedChild.previousSibling;\n        }\n        newChild.parentNode = this;\n        replacedChild.parentNode = null;\n        replacedChild.previousSibling = null;\n        replacedChild.nextSibling = null;\n        return true;\n    },\n    insertAfter: function (node, referenceNode) {\n        if (!node) {\n            return false;\n        }\n        if (referenceNode && referenceNode.parentNode !== this) {\n            return false;\n        }\n        if (isArray(node)) {\n            node.forEach(function (node) {\n                this.insertAfter(node, referenceNode);\n                referenceNode = node;\n            }, this);\n            return true;\n        }\n        if (node === referenceNode) {\n            return false;\n        }\n        if (referenceNode === this.lastChild) {\n            this.appendChild(node);\n            return true;\n        }\n        if (node.parentNode) {\n            node.parentNode.removeChild(node);\n        }\n        if (!referenceNode || referenceNode === this.lastChild) {\n            this.appendChild(node);\n            return true;\n        } else {\n            referenceNode.nextSibling.previousSibling = node;\n            node.nextSibling = referenceNode.nextSibling;\n            node.previousSibling = referenceNode;\n            referenceNode.nextSibling = node;\n        }\n        node.parentNode = this;\n        return true;\n    },\n    insertBefore: function (node, referenceNode) {\n        if (!node) {\n            return false;\n        }\n        if (referenceNode && referenceNode.parentNode !== this) {\n            return false;\n        }\n        if (isArray(node)) {\n            var nodes = node;\n            var i;\n            for (i = nodes.length - 1; i >= 0; i--) {\n                this.insertBefore(nodes[i], referenceNode);\n                referenceNode = nodes[i];\n            }\n            return true;\n        }\n        if (node === referenceNode) {\n            return false;\n        }\n        if (node.parentNode) {\n            node.parentNode.removeChild(node);\n        }\n        if (!referenceNode) {\n            this.appendChild(node);\n        } else if (this.firstChild === referenceNode) {\n            this.firstChild = node;\n            this.firstChild.nextSibling = referenceNode;\n            this.firstChild.previousSibling = null;\n            referenceNode.previousSibling = this.firstChild;\n            node.parentNode = this;\n        } else {\n            this.insertAfter(node, referenceNode.previousSibling);\n        }\n        return true;\n    },\n    __NODE: true,\n    isTextNode: function () {\n        return false;\n    },\n    isElementNode: function () {\n        return false;\n    },\n    setStripExpression: function (stripExpression) {\n        this.stripExpression = stripExpression;\n    },\n\n    addBeforeCode: function (code) {\n        this.beforeCode.push(code);\n    },\n    addAfterCode: function (code) {\n        this.afterCode.push(code);\n    },\n\n    generateCode: function (template) {\n        this.compiler = template.compiler;\n\n        if (this.beforeCode.length) {\n            this.beforeCode.forEach(function (code) {\n                template.indent().code(code).code('\\n');\n            });\n        }\n\n\n        var preserveWhitespace = this.isPreserveWhitespace();\n        if (preserveWhitespace == null) {\n            preserveWhitespace = template.options.preserveWhitespace;\n            if (preserveWhitespace === true || preserveWhitespace && preserveWhitespace['*']) {\n                this.setPreserveWhitespace(true);\n            } else {\n                this.setPreserveWhitespace(false);\n            }\n        }\n        var wordWrapEnabled = this.isWordWrapEnabled();\n        if (wordWrapEnabled == null) {\n            wordWrapEnabled = template.options.wordWrapEnabled;\n            if (wordWrapEnabled !== false) {\n                this.setWordWrapEnabled(true);\n            }\n        }\n        if (this.isEscapeXmlBodyText() == null) {\n            this.setEscapeXmlBodyText(true);\n        }\n        try {\n            if (!this.stripExpression || this.stripExpression.toString() === 'false') {\n                this.doGenerateCode(template);\n            } else if (this.stripExpression.toString() === 'true') {\n                this.generateCodeForChildren(template);\n            } else {\n                //There is a strip expression\n                if (!this.generateBeforeCode || !this.generateAfterCode) {\n                    this.addError('The c-strip directive is not supported for node ' + this);\n                    this.generateCodeForChildren(template);\n                    return;\n                }\n                var nextStripVarId = template.getAttribute('nextStripVarId');\n                if (nextStripVarId == null) {\n                    nextStripVarId = template.setAttribute('nextStripVarId', 0);\n                }\n                var varName = '__strip' + nextStripVarId++;\n                template.statement('var ' + varName + ' = !(' + this.stripExpression + ');');\n                template.statement('if (' + varName + ') {').indent(function () {\n                    this.generateBeforeCode(template);\n                }, this).line('}');\n                this.generateCodeForChildren(template);\n                template.statement('if (' + varName + ') {').indent(function () {\n                    this.generateAfterCode(template);\n                }, this).line('}');\n            }\n        } catch (e) {\n            throw createError(new Error('Unable to generate code for node ' + this + ' at position [' + this.getPosition() + ']. Exception: ' + e), e);\n        }\n\n        if (this.afterCode.length) {\n            this.afterCode.forEach(function (code) {\n                template.indent().code(code).code('\\n');\n            });\n        }\n    },\n    isPreserveWhitespace: function () {\n        return this.preserveWhitespace;\n    },\n    setPreserveWhitespace: function (preserve) {\n        this.preserveWhitespace = preserve;\n    },\n    isWordWrapEnabled: function () {\n        return this.wordWrapEnabled;\n    },\n    setWordWrapEnabled: function (enabled) {\n        this.wordWrapEnabled = enabled;\n    },\n    doGenerateCode: function (template) {\n        this.generateCodeForChildren(template);\n    },\n    generateCodeForChildren: function (template, indent) {\n        if (!template) {\n            throw createError(new Error('The \"template\" argument is required'));\n        }\n        if (indent === true) {\n            template.incIndent();\n        }\n        this.forEachChild(function (childNode) {\n            if (childNode.isPreserveWhitespace() == null) {\n                childNode.setPreserveWhitespace(this.isPreserveWhitespace() === true);\n            }\n            if (childNode.isWordWrapEnabled() == null) {\n                childNode.setWordWrapEnabled(this.isWordWrapEnabled() === true);\n            }\n            if (childNode.isEscapeXmlBodyText() == null) {\n                childNode.setEscapeXmlBodyText(this.isEscapeXmlBodyText() !== false);\n            }\n            if (childNode.getEscapeXmlContext() == null) {\n                childNode.setEscapeXmlContext(this.getEscapeXmlContext() || require('./EscapeXmlContext').ELEMENT);\n            }\n            childNode.generateCode(template);\n        }, this);\n        if (indent === true) {\n            template.decIndent();\n        }\n    },\n    addNamespaceMappings: function (namespaceMappings) {\n        if (!namespaceMappings) {\n            return;\n        }\n        var existingNamespaceMappings = this.namespaceMappings;\n        var prefixMappings = this.prefixMappings;\n        forEachEntry(namespaceMappings, function (prefix, namespace) {\n            existingNamespaceMappings[prefix] = namespace;\n            prefixMappings[namespace] = prefix;\n        });\n    },\n    hasNamespacePrefix: function (namespace) {\n        return this.prefixMappings.hasOwnProperty(namespace);\n    },\n    resolveNamespacePrefix: function (namespace) {\n        var prefix = this.prefixMappings[namespace];\n        return !prefix && this.parentNode ? this.parentNode.resolveNamespacePrefix() : prefix;\n    },\n    forEachNamespace: function (callback, thisObj) {\n        forEachEntry(this.namespaceMappings, callback, thisObj);\n    },\n    getNodeClass: function () {\n        return this.nodeClass || this.constructor;\n    },\n    setNodeClass: function (nodeClass) {\n        this.nodeClass = nodeClass;\n    },\n    prettyPrintTree: function () {\n        var out = [];\n        function printNode(node, indent) {\n            out.push(indent + node.toString() + '\\n');\n            node.forEachChild(function (child) {\n                printNode(child, indent + '  ');\n            });\n        }\n        printNode(this, '');\n        return out.join('');\n    },\n    setEscapeXmlBodyText: function (escapeXmlBodyText) {\n        this.escapeXmlBodyText = escapeXmlBodyText;\n    },\n    isEscapeXmlBodyText: function () {\n        return this.escapeXmlBodyText;\n    },\n    setEscapeXmlContext: function (escapeXmlContext) {\n        if (typeof escapeXmlContext === 'string') {\n            escapeXmlContext = EscapeXmlContext[escapeXmlContext.toUpperCase()];\n        }\n\n        this.escapeXmlContext = escapeXmlContext;\n    },\n    getEscapeXmlContext: function () {\n        return this.escapeXmlContext;\n    }\n};\nmodule.exports = Node;","/home/travis/build/npmtest/node-npmtest-raptor-templates/node_modules/raptor-templates/compiler/EscapeXmlContext.js":"/*\n * Copyright 2011 eBay Software Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nmodule.exports = {\n    'ELEMENT': 'ELEMENT',\n    'ATTRIBUTE': 'ATTRIBUTE'\n};","/home/travis/build/npmtest/node-npmtest-raptor-templates/node_modules/raptor-templates/compiler/ElementNode.js":"/*\n * Copyright 2011 eBay Software Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n'use strict';\nvar createError = require('raptor-util').createError;\nvar escapeXmlAttr = require('raptor-util/escapeXml').attr;\nvar XML_URI = 'http://www.w3.org/XML/1998/namespace';\nvar XML_URI_ALT = 'http://www.w3.org/XML/1998/namespace';\nvar forEachEntry = require('raptor-util').forEachEntry;\n\nfunction isEmpty(o) {\n    if (!o) {\n        return true;\n    }\n    \n    for (var k in o) {\n        if (o.hasOwnProperty(k)) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction ElementNode(localName, namespace, prefix) {\n    ElementNode.$super.call(this, 'element');\n    if (!this._elementNode) {\n        this._elementNode = true;\n        this.dynamicAttributesExpressionArray = null;\n        this.attributesByNS = {};\n        this.prefix = prefix;\n        this.localName = localName;\n        this.namespace = namespace;\n        this.allowSelfClosing = false;\n        this.startTagOnly = false;\n    }\n}\nElementNode.prototype = {\n    addDynamicAttributes: function(expression) {\n        if (!this.dynamicAttributesExpressionArray) {\n            this.dynamicAttributesExpressionArray = [];\n        }\n\n        this.dynamicAttributesExpressionArray.push(expression);\n    },\n    getQName: function () {\n        return this.localName ? (this.prefix ? this.prefix + ':' : '') + this.localName : null;\n    },\n    setStartTagOnly: function (startTagOnly) {\n        this.startTagOnly = true;\n    },\n    setAllowSelfClosing: function (allowSelfClosing) {\n        this.allowSelfClosing = allowSelfClosing;\n    },\n    isElementNode: function () {\n        return true;\n    },\n    isTextNode: function () {\n        return false;\n    },\n    getAllAttributes: function () {\n        var allAttrs = [];\n        forEachEntry(this.attributesByNS, function (namespace, attrs) {\n            forEachEntry(attrs, function (name, attr) {\n                allAttrs.push(attr);\n            });\n        }, this);\n        return allAttrs;\n    },\n    forEachAttributeAnyNS: function (callback, thisObj) {\n        var attributes = [];\n        forEachEntry(this.attributesByNS, function (namespace, attrs) {\n            forEachEntry(attrs, function (name, attr) {\n                attributes.push(attr);\n            });\n        });\n\n        attributes.forEach(callback, thisObj);\n    },\n    forEachAttributeNS: function (namespace, callback, thisObj) {\n        namespace = this.resolveNamespace(namespace);\n\n        var attrs = this.attributesByNS[namespace];\n        if (attrs) {\n            forEachEntry(attrs, function (name, attr) {\n                callback.call(thisObj, attr);\n            });\n        }\n    },\n    getAttributes: function() {\n        return this.getAttributesNS('');\n    },\n    getAttributesNS: function (namespace) {\n        var attributes = [];\n        if (this.attributesByNS[namespace]) {\n            forEachEntry(this.attributesByNS[namespace], function (name, attr) {\n                attributes.push(attr);\n            });    \n        }\n        \n        return attributes;\n    },\n    getAttribute: function (name) {\n        return this.getAttributeNS(null, name);\n    },\n    getAttributeNS: function (namespace, localName) {\n        namespace = this.resolveNamespace(namespace);\n        var attrNS = this.attributesByNS[namespace];\n        var attr = attrNS ? attrNS[localName] : undefined;\n        return attr ? attr.value : undefined;\n    },\n    setAttribute: function (localName, value, escapeXml) {\n        this.setAttributeNS(null, localName, value, null, escapeXml);\n    },\n    setAttributeNS: function (namespace, localName, value, prefix, escapeXml) {\n        namespace = this.resolveNamespace(namespace);\n        var attrNS = this.attributesByNS[namespace] || (this.attributesByNS[namespace] = {});\n        attrNS[localName] = {\n            localName: localName,\n            value: value,\n            prefix: prefix,\n            namespace: namespace,\n            escapeXml: escapeXml,\n            qName: prefix ? prefix + ':' + localName : localName,\n            name: namespace ? namespace + ':' + localName : localName,\n            toString: function () {\n                return this.name;\n            }\n        };\n    },\n    setEmptyAttribute: function (name) {\n        this.setAttribute(name, null);\n    },\n    removeAttribute: function (localName) {\n        this.removeAttributeNS(null, localName);\n    },\n    removeAttributeNS: function (namespace, localName) {\n        namespace = this.resolveNamespace(namespace);\n        var attrNS = this.attributesByNS[namespace] || (this.attributesByNS[namespace] = {});\n        if (attrNS) {\n            delete attrNS[localName];\n            if (isEmpty(attrNS)) {\n                delete this.attributesByNS[namespace];\n            }\n        }\n    },\n    removeAttributesNS: function (namespace) {\n        namespace = this.resolveNamespace(namespace);\n        delete this.attributesByNS[namespace];\n    },\n    isPreserveWhitespace: function () {\n        var preserveSpace = ElementNode.$super.prototype.isPreserveWhitespace.call(this);\n        if (preserveSpace === true) {\n            return true;\n        }\n        var preserveAttr = this.getAttributeNS(XML_URI, 'space') || this.getAttributeNS(XML_URI_ALT, 'space') || this.getAttribute('xml:space') === 'preserve';\n        if (preserveAttr === 'preserve') {\n            return true;\n        }\n        return preserveSpace;\n    },\n    hasAttributesAnyNS: function () {\n        return !isEmpty(this.attributesByNS);\n    },\n    hasAttributes: function () {\n        return this.hasAttributesNS('');\n    },\n    hasAttributesNS: function (namespace) {\n        namespace = this.resolveNamespace(namespace);\n        return this.attributesByNS[namespace] !== undefined;\n    },\n    hasAttribute: function (localName) {\n        return this.hasAttributeNS('', localName);\n    },\n    hasAttributeNS: function (namespace, localName) {\n        namespace = this.resolveNamespace(namespace);\n        var attrsNS = this.attributesByNS[namespace];\n        return attrsNS ? attrsNS.hasOwnProperty(localName) : false;\n    },\n    removePreserveSpaceAttr: function () {\n        this.removeAttributeNS(XML_URI, 'space');\n        this.removeAttributeNS(XML_URI_ALT, 'space');\n        this.removeAttribute('space');\n    },\n    setStripExpression: function (stripExpression) {\n        this.stripExpression = stripExpression;\n    },\n    doGenerateCode: function (template) {\n        this.generateBeforeCode(template);\n        this.generateCodeForChildren(template);\n        this.generateAfterCode(template);\n    },\n    generateBeforeCode: function (template) {\n        var preserveWhitespace = this.preserveWhitespace = this.isPreserveWhitespace();\n        var name = this.prefix ? this.prefix + ':' + this.localName : this.localName;\n        if (preserveWhitespace) {\n            this.removePreserveSpaceAttr();\n        }\n        template.text('<' + name);\n        this.forEachAttributeAnyNS(function (attr) {\n            var prefix = attr.prefix;\n            if (!prefix && attr.namespace) {\n                prefix = this.resolveNamespacePrefix(attr.namespace);\n            }\n            if (prefix) {\n                name = prefix + (attr.localName ? ':' + attr.localName : '');\n            } else {\n                name = attr.localName;\n            }\n            if (attr.value === null || attr.value === undefined) {\n                template.text(' ' + name);\n            } else if (template.isExpression(attr.value)) {\n                template.attr(name, attr.value, attr.escapeXml !== false);\n            } else {\n                var attrParts = [];\n                var hasExpression = false;\n                var invalidAttr = false;\n                template.parseExpression(attr.value, {\n                    text: function (text, escapeXml) {\n                        attrParts.push({\n                            text: text,\n                            escapeXml: escapeXml !== false\n                        });\n                    },\n                    expression: function (expression, escapeXml) {\n                        hasExpression = true;\n                        attrParts.push({\n                            expression: expression,\n                            escapeXml: escapeXml !== false\n                        });\n                    },\n                    error: function (message) {\n                        invalidAttr = true;\n                        this.addError('Invalid expression found in attribute \"' + name + '\". ' + message);\n                    }\n                }, this);\n                \n                if (invalidAttr) {\n                    template.text(name + '=\"' + escapeXmlAttr(attr.value) + '\"');\n                } else {\n                    if (hasExpression && attrParts.length === 1) {\n                        template.attr(name, attrParts[0].expression, attrParts[0].escapeXml !== false);\n                    } else {\n                        template.text(' ' + name + '=\"');\n                        attrParts.forEach(function (part) {\n                            if (part.text) {\n                                template.text(part.escapeXml !== false ? escapeXmlAttr(part.text) : part.text);\n                            } else if (part.expression) {\n                                template.write(part.expression, { escapeXmlAttr: part.escapeXml !== false });\n                            } else {\n                                throw createError(new Error('Illegal state'));\n                            }\n                        });\n                        template.text('\"');\n                    }\n                }\n            }\n        }, this);\n        if (this.dynamicAttributesExpressionArray && this.dynamicAttributesExpressionArray.length) {\n            this.dynamicAttributesExpressionArray.forEach(function(expression) {\n                template.attrs(expression);\n            });\n        }\n        if (this.hasChildren()) {\n            template.text('>');\n        } else {\n            if (this.startTagOnly) {\n                template.text('>');\n            } else if (this.allowSelfClosing) {\n                template.text('/>');\n            }\n        }\n    },\n    generateAfterCode: function (template) {\n        var name = this.prefix ? this.prefix + ':' + this.localName : this.localName;\n        if (this.hasChildren()) {\n            template.text('</' + name + '>');\n        } else {\n            if (!this.startTagOnly && !this.allowSelfClosing) {\n                template.text('></' + name + '>');\n            }\n        }\n    },\n    toString: function () {\n        return '<' + (this.prefix ? this.prefix + ':' + this.localName : this.localName) + '>';\n    }\n};\nrequire('raptor-util').inherit(ElementNode, require('./Node'));\n\nObject.defineProperty(ElementNode.prototype, 'tagName', {\n    get: function() {\n        return this._localName;\n    },\n    set: function(value) {\n        this._localName = value;\n    }\n});\n\nObject.defineProperty(ElementNode.prototype, 'localName', {\n    get: function() {\n        return this._localName;\n    },\n    set: function(value) {\n        this._localName = value;\n    }\n});\n\nObject.defineProperty(ElementNode.prototype, 'qName', {\n    get: function() {\n        if (this.prefix) {\n            return this.prefix + ':' + this.localName;\n        } else {\n            return this.localName;\n        }\n    }\n});\n\nmodule.exports = ElementNode;","/home/travis/build/npmtest/node-npmtest-raptor-templates/node_modules/raptor-templates/compiler/TextNode.js":"/*\n * Copyright 2011 eBay Software Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n'use strict';\nvar createError = require('raptor-util').createError;\nvar escapeXml = require('raptor-util/escapeXml');\nvar EscapeXmlContext = require('./EscapeXmlContext');\n\nvar attrReplace = /[&<>\\\"\\']/g;\nvar replacements = {\n        '<': '&lt;',\n        '>': '&gt;',\n        '&': '&amp;',\n        '\"': '&quot;',\n        '\\'': '&apos;'\n    };\nfunction escapeXmlAttr(str) {\n    return str.replace(attrReplace, function (match) {\n        return replacements[match];\n    });\n}\n\nfunction TextNode(text, escapeXml) {\n    TextNode.$super.call(this, 'text');\n    if (text != null && typeof text !== 'string') {\n        throw createError('Invalid text: ' + text);\n    }\n    this.text = text;\n    this.escapeXml = escapeXml !== false;\n}\nTextNode.prototype = {\n    normalizeText: function () {\n        var normalizedText = this.getEscapedText();\n        var curChild = this.nextSibling;\n        var nodeToRemove;\n        while (curChild && (curChild.isTextNode() || curChild.javaScriptOnly)) {\n            if (curChild.javaScriptOnly) {\n                curChild = curChild.nextSibling;\n                continue;\n            }\n            normalizedText += curChild.getEscapedText();\n            nodeToRemove = curChild;\n            curChild = curChild.nextSibling;\n            nodeToRemove.detach();\n        }\n        this.setText(normalizedText);\n        this.escapeXml = false;    //Make sure the text is not re-escaped\n    },\n    getEscapedText: function () {\n        var text = this.getText();\n        var parentNode = this.parentNode;\n        var shouldEscapeXml = this.escapeXml !== false && parentNode && parentNode.isEscapeXmlBodyText() !== false;\n        if (shouldEscapeXml) {\n            if (this.getEscapeXmlContext() === EscapeXmlContext.ATTRIBUTE) {\n                return escapeXmlAttr(text);\n            } else {\n                return escapeXml(text);\n            }\n        } else {\n            return text;\n        }\n    },\n    trim: function () {\n        var text = this.getText();\n        if (!text) {\n            return;\n        }\n        var parentNode = this.parentNode;\n        if (parentNode && parentNode.trimBodyIndent) {\n            var initialSpaceMatches = /^\\s+/.exec(text);\n            if (initialSpaceMatches) {\n                var indentMatches = /\\n[^\\n]*$/.exec(initialSpaceMatches[0]);\n                if (indentMatches) {\n                    var indentRegExp = new RegExp(indentMatches[0].replace(/\\n/g, '\\\\n'), 'g');\n                    text = text.replace(indentRegExp, '\\n');\n                }\n                text = text.replace(/^\\s*/, '').replace(/\\s*$/, '');\n                this.setText(text);\n            }\n        }\n        if (this.isPreserveWhitespace()) {\n            return;\n        }\n\n        var previousSibling = this.previousSibling;\n        while (previousSibling && previousSibling.javaScriptOnly) {\n            previousSibling = previousSibling.previousSibling;\n        }\n\n        var nextSibling = this.nextSibling;\n        while (nextSibling && nextSibling.javaScriptOnly) {\n            nextSibling = nextSibling.nextSibling;\n        }\n\n        if (!previousSibling) {\n            //First child\n            text = text.replace(/^\\n\\s*/g, '');\n        }\n        if (!nextSibling) {\n            //Last child\n            text = text.replace(/\\n\\s*$/g, '');\n        }\n        if (/^\\n\\s*$/.test(text)) {\n            //Whitespace between elements\n            text = '';\n        }\n        text = text.replace(/\\s+/g, ' ');\n        if (this.isWordWrapEnabled() && text.length > 80) {\n            var start = 0;\n            var end;\n            while (start < text.length) {\n                end = Math.min(start + 80, text.length);\n                var lastSpace = text.substring(start, end).lastIndexOf(' ');\n                if (lastSpace != -1) {\n                    lastSpace = lastSpace + start;    //Adjust offset into original string\n                } else {\n                    lastSpace = text.indexOf(' ', end);    //No space before the 80 column mark... search for the first space after to break on\n                }\n                if (lastSpace != -1) {\n                    text = text.substring(0, lastSpace) + '\\n' + text.substring(lastSpace + 1);\n                    start = lastSpace + 1;\n                } else {\n                    break;\n                }\n            }\n        }\n        this.setText(text);\n    },\n    doGenerateCode: function (template) {\n        /*\n         * After all of the transformation of the tree we\n         * might have ended up with multiple text nodes\n         * as siblings. We want to normalize adjacent\n         * text nodes so that whitespace removal rules\n         * will be correct\n         */\n        this.normalizeText();\n        this.trim();\n        var text = this.getText();\n        if (text) {\n            template.text(text);\n        }\n    },\n    getText: function () {\n        return this.text;\n    },\n    setText: function (text) {\n        this.text = text;\n    },\n    isTextNode: function () {\n        return true;\n    },\n    isElementNode: function () {\n        return false;\n    },\n    setEscapeXml: function (escapeXml) {\n        this.escapeXml = escapeXml;\n    },\n    isEscapeXml: function () {\n        return this.escapeXml;\n    },\n    toString: function () {\n        var text = this.text && this.text.length > 25 ? this.text.substring(0, 25) + '...' : this.text;\n        text = text.replace(/[\\n]/g, '\\\\n');\n        return '[text: ' + text + ']';\n    }\n};\nrequire('raptor-util').inherit(TextNode, require('./Node'));\nmodule.exports = TextNode;","/home/travis/build/npmtest/node-npmtest-raptor-templates/node_modules/raptor-templates/compiler/expression-parser.js":"/*\n * Copyright 2011 eBay Software Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n'use strict';\nvar createError = require('raptor-util').createError;\nvar Expression = require('./Expression');\nvar strings = require('raptor-strings');\nvar stringify = require('raptor-json/stringify');\nvar regexp = require('raptor-regexp');\nvar ok = require('assert').ok;\n\nvar endingTokens = {\n        '${': '}',\n        '$!{': '}',\n        '{%': '%}',\n        '{?': '}',\n        '$': null,\n        '$!': null\n    };\n\nvar parse;\n\nfunction createStartRegExpStr(starts) {\n    var parts = [];\n    starts.forEach(function (start) {\n        parts.push(regexp.escape('\\\\\\\\' + start));\n        parts.push(regexp.escape('\\\\' + start));\n        parts.push(regexp.escape(start));\n    });\n    return parts.join('|');\n}\nvar startRegExpStr = createStartRegExpStr([\n        '{%',\n        '${',\n        '$!{',\n        '$!',\n        '$',\n        '{?'\n    ]);\nfunction createStartRegExp() {\n    return new RegExp(startRegExpStr, 'g');\n}\n\nfunction getLine(str, pos) {\n    var lines = str.split('\\n');\n    var index = 0;\n    var line;\n\n    while (index < lines.length) {\n        line = lines[index];\n        if (pos - line.length + 1 < 0) {\n            break;\n        } else {\n            pos -= line.length + 1;\n        }\n        index++;\n    }\n\n    return {\n        str: line,\n        pos: pos\n    };\n}\nfunction errorContext(str, pos, length) {\n    var line = getLine(str, pos);\n    pos = line.pos;\n    str = line.str;\n    var start = pos - length;\n    var end = pos + length;\n    var i;\n    if (start < 0) {\n        start = 0;\n    }\n    if (end > str.length) {\n        end = str.length;\n    }\n    var prefix = '...';\n    var suffix = '...';\n    var context = '\\n' + prefix + str.substring(start, end) + suffix + '\\n';\n    for (i = 0; i < prefix.length; i++) {\n        context += ' ';\n    }\n    for (i = start; i < end; i++) {\n        context += i === pos ? '^' : ' ';\n    }\n    for (i = 0; i < suffix.length; i++) {\n        context += ' ';\n    }\n    return context;\n}\nfunction getConditionalExpression(expression) {\n    var tokensRegExp = /\"(?:[^\"]|\\\\\")*\"|'(?:[^']|\\\\')*'|\\\\\\\\;|\\\\;|[\\{\\};]/g;\n    var matches;\n    var depth = 0;\n    var parts = [];\n    var partStart = 0;\n    while ((matches = tokensRegExp.exec(expression))) {\n        if (matches[0] === '{') {\n            depth++;\n            continue;\n        } else if (matches[0] === '}') {\n            if (depth !== 0) {\n                depth--;\n                continue;\n            }\n        } else if (matches[0] === '\\\\\\\\;') {\n            /*\n             * 1) Convert \\\\; --> \\;\n             * 2) Start searching again after the single slash\n             */\n            expression = expression.substring(0, matches.index) + '\\\\;' + expression.substring(tokensRegExp.lastIndex);\n            tokensRegExp.lastIndex = matches.index + 1;\n            continue;\n        } else if (matches[0] === '\\\\;') {\n            /*\n             * 1) Convert \\; --> ;\n             * 2) Start searching again after the semicolon\n             */\n            expression = expression.substring(0, matches.index) + ';' + expression.substring(tokensRegExp.lastIndex);\n            tokensRegExp.lastIndex = matches.index + 1;\n            continue;\n        } else if (matches[0] === ';') {\n            if (depth === 0) {\n                parts.push(expression.substring(partStart, matches.index));\n                partStart = tokensRegExp.lastIndex;\n            }\n        }\n    }\n    if (partStart < expression.length) {\n        parts.push(expression.substring(partStart));\n    }\n    function getExpression(part) {\n        var expressionParts = [];\n        parse(part, {\n            text: function (text) {\n                expressionParts.push(stringify(text));\n            },\n            expression: function (expression) {\n                expressionParts.push(expression);\n            }\n        });\n        return expressionParts.join('+');\n    }\n    if (parts.length === 1) {\n        return '(' + parts[0] + ' ? ' + 'null' + ' : \\'\\')';\n    } else if (parts.length === 2) {\n        return '(' + parts[0] + ' ? ' + getExpression(parts[1]) + ' : \\'\\')';\n    } else if (parts.length === 3) {\n        return'(' + parts[0] + ' ? ' + getExpression(parts[1]) + ' : ' + getExpression(parts[2]) + ')';\n    } else {\n        throw new Error('Invalid simple conditional of \"' + expression + '\". Simple conditionals should be in the form {?<expression>;<true-template>[;<false-template>]}');\n    }\n}\nfunction processNestedStrings(expression, foundStrings) {\n    var hasExpression;\n    var parts;\n    function handleText(text) {\n        parts.push(foundString.quote + text + foundString.quote);\n    }\n    function handleExpression(expression) {\n        hasExpression = true;\n        parts.push(expression);\n    }\n    for (var i = foundStrings.length - 1, foundString; i >= 0; i--) {\n        foundString = foundStrings[i];\n        if (!foundString.value) {\n            continue;\n        }\n        hasExpression = false;\n        parts = [];\n        parse(foundString.value, {\n            text: handleText,\n            expression: handleExpression\n        });\n        if (hasExpression) {\n            expression = expression.substring(0, foundString.start) + '(' + parts.join('+') + ')' + expression.substring(foundString.end);\n        }\n    }\n    return expression;\n}\n\nfunction ExpressionParserHelper(listeners) {\n    this.listeners = listeners;\n    this.prevText = null;\n    this.prevEscapeXml = null;\n}\n\nExpressionParserHelper.prototype = {\n    _invokeCallback: function (name, value, escapeXml) {\n        if (!this.listeners[name]) {\n            throw createError(new Error(name + ' not allowed: ' + value));\n        }\n        this.listeners[name](value, escapeXml);\n    },\n    _endText: function () {\n        if (this.prevText !== null) {\n            this._invokeCallback('text', this.prevText, this.prevEscapeXml);\n            this.prevText = null;\n            this.prevEscapeXml = null;\n        }\n    },\n    addXmlText: function (xmlText) {\n        this.addText(xmlText, false);\n    },\n    addText: function (text, escapeXml) {\n        if (this.prevText !== null && this.prevEscapeXml === escapeXml) {\n            this.prevText += text;\n        } else {\n            this._endText();\n            this.prevText = text;\n            this.prevEscapeXml = escapeXml;\n        }\n    },\n    addUnescapedExpression: function (expression, escapeXml) {\n        this.addExpression(expression, false);\n    },\n    addExpression: function (expression, escapeXml) {\n        this._endText();\n        escapeXml = escapeXml !== false;\n\n        if (!(expression instanceof Expression)) {\n            if (!escapeXml) {\n                // The expression might be a ternary operator\n                // so we need to surround it with parentheses.\n                // Minification will remove unnecessary parentheses.\n                // We don't need to surround with parentheses if\n                // the expression will be escaped since the expression\n                // is an argument to a function call\n                expression = 'str(' + expression + ')';\n            }\n            expression = new Expression(expression);\n        }\n        this._invokeCallback('expression', expression, escapeXml !== false);\n    },\n    addScriptlet: function (scriptlet) {\n        this._endText();\n        this._invokeCallback('scriptlet', scriptlet);\n    }\n};\n\n\n/**\n * @memberOf raptor/templating/compiler$ExpressionParser\n *\n * @param str\n * @param callback\n * @param thisObj\n */\nparse = function (str, listeners, options) {\n\n    ok(str != null, '\"str\" is required');\n    \n    if (!options) {\n        options = {};\n    }\n    var textStart = 0;\n    var textEnd;\n    var startMatches;\n    var endMatches;\n    var expressionStart;\n    var expression;\n    var isScriptlet;\n    var isConditional;\n    var startToken;\n    var custom = options.custom || {};\n    function handleError(message) {\n        if (listeners.error) {\n            listeners.error(message);\n            return;\n        } else {\n            throw createError(new Error(message));\n        }\n    }\n    var startRegExp = createStartRegExp();\n    var helper = new ExpressionParserHelper(listeners);\n    startRegExp.lastIndex = 0;\n    /*\n     * Look for any of the possible start tokens (including the escaped and double-escaped versions)\n     */\n    outer:\n        while ((startMatches = startRegExp.exec(str))) {\n            if (strings.startsWith(startMatches[0], '\\\\\\\\')) {\n                // \\\\${\n                /*\n                 * We found a double-escaped start token.\n                 *\n                 * We found a start token that is preceeded by an escaped backslash...\n                 * The start token is a valid start token preceded by an escaped\n                 * backslash. Add a single black slash and handle the expression\n                 */\n                textEnd = startMatches.index + 1;\n                //Include everything up to and include the first backslash as part of the text\n                startToken = startMatches[0].substring(2);\n                //Record the start token\n                expressionStart = startMatches.index + startMatches[0].length;    //The expression starts after the start token\n            } else if (strings.startsWith(startMatches[0], '\\\\')) {\n                // \\${\n                /*\n                 * We found a start token that is escaped. We should\n                 * add the unescaped start token to the text output.\n                 */\n                helper.addText(str.substring(textStart, startMatches.index));\n                //Add everything preceeding the start token\n                helper.addText(startMatches[0].substring(1));\n                //Add the start token excluding the initial escape character\n                textStart = startRegExp.lastIndex;\n                // The next text block we find will be after this match\n                continue;\n            } else if (endingTokens.hasOwnProperty(startMatches[0])) {\n                /*\n                 * We found a valid start token\n                 */\n                startToken = startMatches[0];\n                //Record the start token\n                textEnd = startMatches.index;    //The text ends where the start token begins\n            } else {\n                throw createError(new Error('Illegal state. Unexpected start token: ' + startMatches[0]));\n            }\n            expressionStart = startRegExp.lastIndex;\n            //Expression starts where the start token ended\n            if (textStart !== textEnd) {\n                //If there was any text between expressions then add it now\n                helper.addText(str.substring(textStart, textEnd));\n            }\n            var endToken = endingTokens[startToken];\n            //Look up the end token\n            if (!endToken) {\n                var variableRegExp = /^([_a-zA-Z]\\w*(?:\\.[_a-zA-Z]\\w*)*)/g;\n                variableRegExp.lastIndex = 0;\n                var variableMatches = variableRegExp.exec(str.substring(expressionStart));\n                //Find the variable name that follows the starting \"$\" token\n                if (!variableMatches) {\n                    //We did not find a valid variable name after the starting \"$\" token\n                    //handleError('Invalid simple variable expression. Location: ' + errorContext(str, expressionStart, 10)); //TODO: Provide a more helpful error message\n                    helper.addText(startMatches[0]);\n                    startRegExp.lastIndex = textStart = expressionStart;\n                    continue outer;\n                }\n                var varName = variableMatches[1];\n                if (startToken === '$!') {\n                    helper.addUnescapedExpression(varName);    //Add the variable as an expression\n                } else {\n                    helper.addExpression(varName);    //Add the variable as an expression\n                }\n                startRegExp.lastIndex = textStart = expressionStart = expressionStart + varName.length;\n                continue outer;\n            }\n            isScriptlet = startToken === '{%';\n            isConditional = startToken === '{?';\n            var endRegExp = /\"((?:[^\"]|\\\\\")*)\"|'((?:[^']|\\\\')*)'|\\%\\}|[\\{\\}]/g;\n            //Now we need to find the ending curly\n            endRegExp.lastIndex = expressionStart;\n            var depth = 0;\n            var foundStrings = [];\n            var handler;\n            while ((endMatches = endRegExp.exec(str))) {\n                if (endMatches[0] === '{') {\n                    depth++;\n                    continue;\n                } else if (endMatches[0] === '}') {\n                    if (isScriptlet) {\n                        continue;\n                    }\n                    if (depth !== 0) {\n                        depth--;\n                        continue;\n                    }\n                } else if (endMatches[0] === '%}') {\n                    if (!isScriptlet) {\n                        handleError('Ending \"' + endMatches[0] + '\" token was found but matched with starting \"' + startToken + '\" token. Location: ' + errorContext(str, endMatches.index, 10));\n                    }\n                } else {\n                    if (endMatches[0].charAt(0) === '\\'' || endMatches[0].charAt(0) === '\"') {\n                        foundStrings.push({\n                            start: endMatches.index - expressionStart,\n                            end: endMatches.index + endMatches[0].length - expressionStart,\n                            value: endMatches[0].slice(1, -1),\n                            json: endMatches[0],\n                            quote: endMatches[0].charAt(0)\n                        });\n                    }\n                    continue;\n                }\n                //console.log(\"EXPRESSION: \" + str.substring(firstCurly+1, endMatches.index));\n                expression = str.substring(expressionStart, endMatches.index);\n                handler = null;\n                if (startToken === '${') {\n                    var firstColon = expression.indexOf(':');\n                    var customType;\n                    if (firstColon != -1) {\n                        customType = expression.substring(0, firstColon);\n                        handler = custom[customType] || exports.custom[customType];\n                        if (handler) {\n                            handler.call(exports, expression.substring(firstColon + 1), helper);\n                        }\n                    }\n                }\n                if (!handler) {\n                    if (isScriptlet) {\n                        helper.addScriptlet(expression);\n                    } else if (isConditional) {\n                        helper.addExpression(getConditionalExpression(expression));\n                    } else {\n                        if (foundStrings.length > 0) {\n                            expression = processNestedStrings(expression, foundStrings);\n                        }\n                        if (startToken === '$!{') {\n                            helper.addUnescapedExpression(expression);\n                        } else {\n                            helper.addExpression(expression);\n                        }\n                    }\n                }\n                startRegExp.lastIndex = endRegExp.lastIndex;\n                //Start searching from where the end token ended\n                textStart = endRegExp.lastIndex;\n                //console.log('Found ending curly. Start index now: ' + searchStart);\n                continue outer;\n            }\n            handleError('Ending \"' + endingTokens[startToken] + '\" token not found for \"' + startToken + '\" token. Location: ' + errorContext(str, startMatches.index, 10) + '\\n');\n        }\n    if (textStart !== str.length) {\n        helper.addText(str.substring(textStart, str.length));\n    }\n    helper._endText();\n};\n\nfunction hasExpression(str) {\n    var hasExpressionFlag = false;\n    parse(str, {\n        text: function (text) {\n        },\n        expression: function (expression) {\n            hasExpressionFlag = true;\n        }\n    });\n\n    return hasExpressionFlag;\n}\n\nexports.hasExpression = hasExpression;\nexports.parse = parse;\nexports.custom = {\n    'xml': function (expression, helper) {\n        helper.addUnescapedExpression(new Expression(expression));\n    },\n    'entity': function (expression, helper) {\n        helper.addXmlText('&' + expression + ';');\n    },\n    'startTag': function (expression, helper) {\n        helper.addXmlText('<' + expression + '>');\n    },\n    'endTag': function (expression, helper) {\n        helper.addXmlText('</' + expression + '>');\n    },\n    'newline': function (expression, helper) {\n        helper.addText('\\n');\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-raptor-templates/node_modules/raptor-templates/compiler/Expression.js":"/*\n * Copyright 2011 eBay Software Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n'use strict';\nvar createError = require('raptor-util').createError;\nvar operatorsRegExp = /\"(?:[^\"]|\\\\\")*\"|'(?:[^']|\\\\')*'|\\s+(?:and|or|lt|gt|eq|ne|lt|gt|ge|le)\\s+/g;\nvar replacements = {\n        'and': ' && ',\n        'or': ' || ',\n        'eq': ' === ',\n        'ne': ' !== ',\n        'lt': ' < ',\n        'gt': ' > ',\n        'ge': ' >= ',\n        'le': ' <= '\n    };\nfunction handleBinaryOperators(str) {\n    return str.replace(operatorsRegExp, function (match) {\n        return replacements[match.trim()] || match;\n    });\n}\nfunction Expression(expression, replaceSpecialOperators) {\n    if (expression == null) {\n        throw createError(new Error('expression argument is required'));\n    }\n    if (replaceSpecialOperators !== false && typeof expression === 'string') {\n        expression = handleBinaryOperators(expression);\n    }\n    this.expression = expression;\n}\nExpression.prototype = {\n    getExpression: function () {\n        return this.expression;\n    },\n    toString: function () {\n        return this.expression.toString();\n    }\n};\nmodule.exports = Expression;","/home/travis/build/npmtest/node-npmtest-raptor-templates/node_modules/raptor-templates/compiler/TypeConverter.js":"/*\n * Copyright 2011 eBay Software Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n'use strict';\nvar createError = require('raptor-util').createError;\nvar expressionParser = require('./expression-parser');\nvar stringify = require('raptor-json/stringify');\nvar Expression = require('./Expression');\nfunction TypeConverter() {\n}\nTypeConverter.convert = function (value, targetType, allowExpressions) {\n    var hasExpression = false;\n    var expressionParts = [];\n    if (value == null) {\n        return value;\n    }\n    if (targetType === 'custom' || targetType === 'identifier') {\n        return value;\n    }\n\n\n\n    if (targetType === 'expression') {\n        if (value === '') {\n            value = 'null';\n        }\n        return new Expression(value);\n    }\n    var processedText = '';\n    if (allowExpressions) {\n        expressionParser.parse(value, {\n            text: function (text) {\n                processedText += text;\n                expressionParts.push(stringify(text));\n            },\n            expression: function (expression) {\n                expressionParts.push(expression);\n                hasExpression = true;\n            }\n        });\n\n        if (hasExpression) {\n            value = new Expression(expressionParts.join('+'));\n\n            if (targetType === 'template') {\n                return new Expression('__helpers.l(' + value + ')');\n            } else {\n                return value;\n            }\n        }\n\n        value = processedText;\n    }\n    if (targetType === 'string') {\n        return allowExpressions ? new Expression(value != null ? stringify(value) : 'null') : value;\n    } else if (targetType === 'boolean') {\n        if (allowExpressions) {\n            return new Expression(value);\n        } else {\n            value = value.toLowerCase();\n            value = value === 'true' || value === 'yes';\n            //convert it to a boolean\n            return value;\n        }\n    } else if (targetType === 'float' || targetType === 'double' || targetType === 'number' || targetType === 'integer' || targetType === 'int') {\n        if (allowExpressions) {\n            return new Expression(value);\n        } else {\n            if (targetType === 'integer') {\n                value = parseInt(value, 10);\n            } else {\n                value = parseFloat(value);\n            }\n            return value;\n        }\n    } else if (targetType === 'path') {\n        return new Expression('require.resolve(' + JSON.stringify(value) + ')');\n    } else if (targetType === 'template') {\n        return new Expression('__helpers.l(require.resolve(' + JSON.stringify(value) + '))');\n    } else {\n        throw createError(new Error('Unsupported attribute type: ' + targetType));\n    }\n};\nmodule.exports = TypeConverter;","/home/travis/build/npmtest/node-npmtest-raptor-templates/node_modules/raptor-templates/compiler/TemplateCompiler.js":"/*\n * Copyright 2011 eBay Software Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n'use strict';\nvar createError = require('raptor-util').createError;\nvar TemplateBuilder = require('./TemplateBuilder');\nvar parser = require('./parser');\nvar Expression = require('./Expression');\nvar TypeConverter = require('./TypeConverter');\nvar taglibs = require('./taglibs');\nvar nodePath = require('path');\nvar ok = require('assert').ok;\nvar attributeParser = require('./attribute-parser');\nvar expressionParser = require('./expression-parser');\nvar inherit = require('raptor-util/inherit');\nvar _Node = require('./Node');\nvar ElementNode = require('./ElementNode');\nvar TextNode = require('./TextNode');\nvar TagHandlerNode = require('../taglibs/core/TagHandlerNode');\nvar raptorModulesResolver = require('raptor-modules/resolver');\nvar fs = require('fs');\n\nfunction TemplateCompiler(path, options) {\n    this.dirname = nodePath.dirname(path);\n    this.path = path;\n    this.taglibs = taglibs.buildLookup(this.dirname);\n    this.options = options || {};\n    this.errors = [];\n}\n\nTemplateCompiler.prototype = {\n    isTaglib: function(ns) {\n        return this.taglibs.isTaglib(ns);\n    },\n\n    transformTree: function (rootNode, templateBuilder) {\n        if (!templateBuilder) {\n            throw createError(new Error('The templateBuilder argument is required'));\n        }\n\n        var _this = this;\n\n        function transformTreeHelper(node) {\n            try {\n                _this.taglibs.forEachNodeTransformer(node, function (transformer) {\n\n                    if (!node.isTransformerApplied(transformer)) {\n                        //Check to make sure a transformer of a certain type is only applied once to a node\n                        node.setTransformerApplied(transformer);\n                        //Mark the node as have been transformed by the current transformer\n                        _this._transformerApplied = true;\n                        //Set the flag to indicate that a node was transformed\n                        node.compiler = _this;\n                        var transformerFunc = transformer.getFunc();\n                        transformerFunc.call(transformer, node, _this, templateBuilder);    //Have the transformer process the node (NOTE: Just because a node is being processed by the transformer doesn't mean that it has to modify the parse tree)\n                    }\n                });\n            } catch (e) {\n                throw createError(new Error('Unable to compile template at path \"' + _this.path + '\". Error: ' + e.message), e);\n            }\n            /*\n             * Now process the child nodes by looping over the child nodes\n             * and transforming the subtree recursively\n             *\n             * NOTE: The length of the childNodes array might change as the tree is being performed.\n             *       The checks to prevent transformers from being applied multiple times makes\n             *       sure that this is not a problem.\n             */\n            node.forEachChild(function (childNode) {\n                if (!childNode.parentNode) {\n                    return;    //The child node might have been removed from the tree\n                }\n                transformTreeHelper(childNode);\n            });\n        }\n        /*\n         * The tree is continuously transformed until we go through an entire pass where\n         * there were no new nodes that needed to be transformed. This loop makes sure that\n         * nodes added by transformers are also transformed.\n         */\n        do {\n            this._transformerApplied = false;\n            //Reset the flag to indicate that no transforms were yet applied to any of the nodes for this pass\n            transformTreeHelper(rootNode);    //Run the transforms on the tree\n        } while (this._transformerApplied);\n    },\n    compile: function (src, callback, thisObj) {\n        var _this = this;\n        var filePath = this.path;\n        var rootNode;\n        var templateBuilder;\n\n        function returnError(err) {\n            if (callback) {\n                return callback.call(thisObj, err);\n            } else {\n                throw err;\n            }\n        }\n\n        try {\n            /*\n             * First build the parse tree for the tempate\n             */\n            rootNode = parser.parse(src, filePath, this.taglibs);\n            //Build a parse tree from the input XML\n            templateBuilder = new TemplateBuilder(this, filePath, rootNode);\n            //The templateBuilder object is need to manage the compiled JavaScript output\n            this.transformTree(rootNode, templateBuilder);\n        } catch (e) {\n            var err = createError(new Error('An error occurred while trying to compile template at path \"' + filePath + '\". Exception: ' + (e.stack || e)), e);\n            return returnError(err);\n        }\n\n        try {\n            /*\n             * The tree has been transformed and we can now generate\n             */\n            rootNode.generateCode(templateBuilder);    //Generate the code and have all output be managed by the TemplateBuilder\n        } catch (e) {\n            var err = createError(new Error('An error occurred while trying to compile template at path \"' + filePath + '\". Exception: ' + e), e);\n            return returnError(err);\n        }\n\n        if (this.hasErrors()) {\n            var message = 'An error occurred while trying to compile template at path \"' + filePath + '\". Error(s) in template:\\n';\n            var errors = _this.getErrors();\n            for (var i = 0, len = errors.length; i < len; i++) {\n                message += (i + 1) + ') ' + (errors[i].pos ? '[' + errors[i].pos + '] ' : '') + errors[i].message + '\\n';\n            }\n            var error = new Error(message);\n            error.errors = _this.getErrors();\n            return returnError(error);\n        } else {\n            var output = templateBuilder.getOutput();\n            if (callback) {\n                callback.call(thisObj, null, output);\n            }\n            return output;\n        }\n    },\n    isExpression: function (expression) {\n        return expression instanceof Expression;\n    },\n    hasExpression: function(str) {\n        return expressionParser.hasExpression(str);\n    },\n    makeExpression: function (expression) {\n        if (this.isExpression(expression)) {\n            return expression;\n        } else {\n            return new Expression(expression);\n        }\n    },\n    parseExpression: function(str, listeners, options) {\n        return expressionParser.parse(str, listeners, options);\n    },\n    parseAttribute: function(attr, types, options) {\n        return attributeParser.parse(attr, types, options);\n    },\n    createTagHandlerNode: function (tagName) {\n        var tag = this.taglibs.getTag(tagName);\n        var tagHandlerNode = this.createNode(TagHandlerNode, tag);\n        tagHandlerNode.localName = tagName;\n        return tagHandlerNode;\n    },\n    convertType: function (value, type, allowExpressions) {\n        return TypeConverter.convert(value, type, allowExpressions);\n    },\n    addError: function (message, pos) {\n        this.errors.push({\n            message: message,\n            pos: pos\n        });\n    },\n    hasErrors: function () {\n        return this.errors.length !== 0;\n    },\n    getErrors: function () {\n        return this.errors;\n    },\n    getNodeClass: function (tagName) {\n        ok(arguments.length === 1, 'Invalid args');\n\n        var tag = this.taglibs.getTag(tagName);\n        if (tag && tag.nodeClass) {\n            var nodeClass = require(tag.nodeClass);\n            nodeClass.prototype.constructor = nodeClass;\n            return nodeClass;\n        }\n        throw createError(new Error('Node class not found for tag \"' + tagName + '\"'));\n    },\n    createTag: function () {\n        var Taglib = require('./Taglib');\n        return new Taglib.Tag();\n    },\n\n    inheritNode: function(Ctor) {\n        if (!Ctor.prototype.__NODE) {\n            var nodeType = Ctor.nodeType || 'node';\n            nodeType = nodeType.toLowerCase();\n\n            if (nodeType === 'element') {\n                inherit(Ctor, ElementNode);\n            } else if (nodeType === 'node') {\n                inherit(Ctor, _Node);\n            } else {\n                throw new Error('Invalid node type: ' + nodeType);\n            }\n        }\n    },\n\n    createNode: function(Ctor, arg) {\n        if (typeof Ctor === 'string') {\n            var tagName = Ctor;\n            Ctor = this.getNodeClass(tagName);\n        }\n\n        ok(Ctor != null, 'Ctor is required');\n        ok(typeof Ctor === 'function', 'Ctor should be a function');\n\n        this.inheritNode(Ctor);\n\n        return new Ctor(arg);\n    },\n\n    createTextNode: function(text, escapeXml) {\n        return new TextNode(text, escapeXml);\n    },\n\n    getLastModified: function() {\n        var sourceFile = this.path;\n\n        var statSource = fs.statSync(sourceFile);\n\n        var lastModifiedTime = statSource.mtime.getTime();\n\n        var taglibFiles = this.taglibs.getInputFiles();\n        var len = taglibFiles.length;\n        for (var i=0; i<len; i++) {\n            var taglibFileStat;\n            var taglibFile = taglibFiles[i];\n\n            try {\n                taglibFileStat = fs.statSync(taglibFile);\n            } catch(e) {\n                continue;\n            }\n\n            lastModifiedTime = Math.max(lastModifiedTime, taglibFileStat.mtime.getTime());\n        }\n\n        return lastModifiedTime;\n    },\n\n    checkUpToDate: function(targetFile) {\n        if (this.options.checkUpToDate === false) {\n            return false;\n        }\n\n        var sourceFile = this.path;\n\n        var statTarget;\n\n        try {\n            statTarget = fs.statSync(targetFile);\n        } catch(e) {\n            return false;\n        }\n\n        var statSource = fs.statSync(sourceFile);\n\n        if (statSource.mtime.getTime() > statTarget.mtime.getTime()) {\n            return false;\n        }\n\n        // Now check if any of the taglib files have been modified after the target file was generated\n\n        var taglibFiles = this.taglibs.getInputFiles();\n        var len = taglibFiles.length;\n        for (var i=0; i<len; i++) {\n            var taglibFileStat;\n            var taglibFile = taglibFiles[i];\n\n            try {\n                taglibFileStat = fs.statSync(taglibFile);\n            } catch(e) {\n                continue;\n            }\n\n            if (taglibFileStat.mtime.getTime() > statTarget.mtime.getTime()) {\n                return false;\n            }\n        }\n\n        return true;\n\n    },\n    getRequirePath: function(targetModuleFile) {\n        return raptorModulesResolver.deresolve(targetModuleFile, this.dirname);\n    }\n};\nmodule.exports = TemplateCompiler;\n","/home/travis/build/npmtest/node-npmtest-raptor-templates/node_modules/raptor-templates/compiler/TemplateBuilder.js":"/*\n * Copyright 2011 eBay Software Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n'use strict';\nvar createError = require('raptor-util').createError;\nvar nodePath = require('path');\nvar stringify = require('raptor-json/stringify');\nvar StringBuilder = require('raptor-strings/StringBuilder');\nvar Expression = require('./Expression');\nvar arrayFromArguments = require('raptor-util').arrayFromArguments;\nvar INDENT = '  ';\n\nfunction writeArg(writer, arg) {\n    if (typeof arg === 'string') {\n        writer._code.append(arg);\n    } else if (typeof arg === 'boolean') {\n        writer._code.append(arg ? 'true' : 'false');\n    } else if (typeof arg === 'function') {\n        arg();\n    } else if (arg instanceof Expression) {\n        writer._code.append( arg.toString() );\n    } else if (arg) {\n        writer._code.append(arg.toString());\n    } else {\n        throw createError(new Error('Illegal arg: ' + arg.toString()));\n    }\n}\n\nfunction writeArgs(writer, args) {\n    for (var i=0, len=args.length; i<len; i++) {\n        var arg = args[i];\n        if (i !== 0) {\n            writer._code.append(', ');\n        }\n\n        writeArg(writer, arg);\n    }\n}\n\n\nfunction safeVarName(varName) {\n    return varName.replace(/[^A-Za-z0-9_]/g, '_').replace(/^[0-9]+/, function(match) {\n        var str = '';\n        for (var i=0; i<match.length; i++) {\n            str += '_';\n        }\n        return str;\n    });\n}\n\nfunction CodeWriter(concatWrites, indent) {\n    this._indent = indent != null ? indent : INDENT + INDENT;\n    this._code = new StringBuilder();\n    this.firstStatement = true;\n    this._bufferedText = null;\n    this._bufferedWrites = null;\n    this.concatWrites = concatWrites;\n}\nCodeWriter.prototype = {\n    write: function (expression) {\n        this.flushText();\n        if (!this._bufferedWrites) {\n            this._bufferedWrites = [];\n        }\n        \n        this._bufferedWrites.push(expression);\n\n\n    },\n    text: function (text) {\n        if (this._bufferedText === null) {\n            this._bufferedText = text;\n        } else {\n            this._bufferedText += text;\n        }\n    },\n    functionCall: function (varName, args) {\n        this.flush();\n        this._code.append(this._indent + varName + '(');\n        writeArgs(this, args);\n        this._code.append(');\\n');\n    },\n    code: function (code) {\n        this.flush();\n        this._code.append(code);\n    },\n    statement: function (code) {\n        this.flush();\n        this.code((this.firstStatement ? '' : '\\n') + this._indent + code + '\\n');\n        this.firstStatement = false;\n    },\n    line: function (code) {\n        this.code(this._indent + code + '\\n');\n    },\n    indentStr: function (delta) {\n        if (arguments.length === 0) {\n            return this._indent;\n        } else {\n            var indent = this._indent;\n            for (var i = 0; i < delta; i++) {\n                indent += INDENT;\n            }\n            return indent;\n        }\n    },\n    indent: function () {\n        if (arguments.length === 0) {\n            this.code(this._indent);\n        } else if (arguments.length === 1 && typeof arguments[0] === 'number') {\n            this.code(this.indentStr(arguments[0]));\n        } else if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function') {\n            var func;\n            var thisObj;\n            var delta;\n            if (typeof arguments[0] === 'function') {\n                delta = 1;\n                func = arguments[0];\n                thisObj = arguments[1];\n            } else {\n                delta = arguments[0];\n                func = arguments[1];\n                thisObj = arguments[2];\n            }\n            this.incIndent(delta);\n            func.call(thisObj);\n            this.decIndent(delta);\n        } else if (typeof arguments[0] === 'string') {\n            this.code(this._indent + arguments[0]);\n        }\n        return this;\n    },\n    flush: function () {\n        this.flushText();\n        this.flushWrites();\n    },\n    flushText: function () {\n        var curText = this._bufferedText;\n        if (curText) {\n            this._bufferedText = null;\n            this.write(stringify(curText, { useSingleQuote: true }));\n        }\n    },\n    flushWrites: function () {\n        var _this = this;\n        var code = this._code;\n\n        function concat() {\n\n            code.append(_this.indentStr() + 'context.w(');\n\n            _bufferedWrites.forEach(function (expression, i) {\n                if (i !== 0) {\n                    _this.incIndent();\n                    code.append(' +\\n' + this.indentStr());\n                }\n\n                writeArg(_this, expression);\n\n                if (i !== 0) {\n                    _this.decIndent();\n                }\n            }, _this);\n\n            code.append(');\\n');\n        }\n\n        function chain() {\n            _bufferedWrites.forEach(function (arg, i) {\n                \n                if (i === 0) {\n                    this._code.append(this.indentStr() + 'context.w(');\n                } else {\n                    this.incIndent();\n                    this._code.append(this.indentStr() + '.w(');\n                }\n\n                writeArg(this, arg);\n\n                if (i < _bufferedWrites.length - 1) {\n                    this._code.append(')\\n');\n                } else {\n                    this._code.append(');\\n');\n                }\n                if (i !== 0) {\n                    this.decIndent();\n                }\n            }, _this);\n        }\n\n        var _bufferedWrites = this._bufferedWrites;\n        if (_bufferedWrites) {\n            if (!this.firstStatement) {\n                this._code.append('\\n');\n            }\n            this.firstStatement = false;\n            this._bufferedWrites = null;\n            if (this.concatWrites) {\n                concat();\n            } else {\n                chain();\n            }\n            \n        }\n    },\n    incIndent: function (delta) {\n        if (arguments.length === 0) {\n            delta = 1;\n        }\n        this.flush();\n        this._indent = this.indentStr(delta);\n        this.firstStatement = true;\n    },\n    decIndent: function (delta) {\n        if (arguments.length === 0) {\n            delta = 1;\n        }\n        this.flush();\n        this._indent = this._indent.substring(INDENT.length * delta);\n        this.firstStatement = false;\n    },\n    getOutput: function () {\n        this.flush();\n        return this._code.toString();\n    }\n};\nfunction TemplateBuilder(compiler, path, rootNode) {\n    this.rootNode = rootNode;\n    this.compiler = compiler;\n    this.path = path;\n    this.dirname = nodePath.dirname(path);\n    this.options = compiler.options || {};\n    this.templateName = null;\n    this.attributes = {};\n    this.concatWrites = this.options.concatWrites !== false;\n    this.writer = new CodeWriter(this.concatWrites);\n    this.staticVars = [];\n    this.staticVarsLookup = {};\n    this.helperFunctionsAdded = {};\n    this.vars = [];\n    this.varsLookup = {};\n\n    this.getStaticHelperFunction('str', 's');\n    this.getStaticHelperFunction('empty', 'e');\n    this.getStaticHelperFunction('notEmpty', 'ne');\n}\n\nTemplateBuilder.prototype = {\n\n    captureCode: function (func, thisObj) {\n        var oldWriter = this.writer;\n        var newWriter = new CodeWriter(this.concatWrites, oldWriter.indentStr());\n        try {\n            this.writer = newWriter;\n            func.call(thisObj);\n            return newWriter.getOutput();\n        } finally {\n            this.writer = oldWriter;\n        }\n    },\n    getStaticHelperFunction: function (varName, propName) {\n        \n        var added = this.helperFunctionsAdded[propName];\n        if (added) {\n            return added;\n        } else {\n            this.addStaticVar(varName, '__helpers.' + propName);\n            this.helperFunctionsAdded[propName] = varName;\n            return varName;\n        }\n    },\n    hasStaticVar: function (name) {\n        return this.staticVarsLookup[name] === true;\n    },\n    addStaticVar: function (name, expression) {\n        name = safeVarName(name);\n        \n        if (!this.staticVarsLookup.hasOwnProperty(name)) {\n            this.staticVarsLookup[name] = true;\n            this.staticVars.push({\n                name: name,\n                expression: expression\n            });\n        }\n        return name;\n    },\n    hasVar: function (name) {\n        return this.vars[name] === true;\n    },\n    addVar: function (name, expression) {\n        name = safeVarName(name);\n        \n        this.vars[name] = true;\n        this.vars.push({\n            name: name,\n            expression: expression\n        });\n    },\n    _writeVars: function (vars, out, indent) {\n        if (!vars.length) {\n            return;\n        }\n        out.append(indent + 'var ');\n        var declarations = [];\n        vars.forEach(function (v, i) {\n            declarations.push((i !== 0 ? indent + '    ' : '') + v.name + ' = ' + v.expression + (i === vars.length - 1 ? ';\\n' : ',\\n'));\n        });\n        out.append(declarations.join(''));\n    },\n    text: function (text) {\n        if (!this.hasErrors()) {\n            this.writer.text(text);\n        }\n        return this;\n    },\n    attr: function (name, valueExpression, escapeXml) {\n        if (!this.hasErrors()) {\n            var expression;\n\n            if (escapeXml === false) {\n                expression = this.getStaticHelperFunction('attr', 'a') + '(' + stringify(name) + ', ' + valueExpression + ', false)';\n            } else {\n                expression = this.getStaticHelperFunction('attr', 'a') + '(' + stringify(name) + ', ' + valueExpression + ')';\n            }\n\n            this.write(expression);\n        }\n\n        return this;\n    },\n    attrs: function (attrsExpression) {\n        if (!this.hasErrors()) {\n            var expression = this.getStaticHelperFunction('attrs', 'as') + '(' + attrsExpression + ')';\n            this.write(expression);\n        }\n        return this;\n    },\n    include: function (templatePath, dataExpression) {\n        if (!this.hasErrors()) {\n\n            if (typeof templatePath === 'string') {\n                var templateVar;\n                if (!this.hasExpression(templatePath)) {\n                    // Resolve the static string to a full path only once\n                    templateVar = this.addStaticVar(templatePath, '__helpers.l(require.resolve(' + this.compiler.convertType(templatePath, 'string', true) + '))');\n                    this.statement(this.makeExpression(templateVar + '.render(' + dataExpression + ', context);'));\n                    return;\n                }\n            }\n\n            this.contextHelperMethodCall('i', typeof templatePath === 'string' ? this.compiler.convertType(templatePath, 'string', true) : templatePath, dataExpression);\n        }\n        return this;\n    },\n    load: function (templatePath) {\n        if (!this.hasErrors()) {\n            this.contextHelperMethodCall('l', new Expression('require.resolve(' + templatePath + ')'));\n        }\n        return this;\n    },\n    functionCall: function(varName, args) {\n        if (!this.hasErrors()) {\n            args = arrayFromArguments(arguments, 1);\n            this.writer.functionCall(varName, args);\n        }\n        return this;\n    },\n    contextHelperMethodCall: function (methodName, args) {\n        if (!this.hasErrors()) {\n            args = arrayFromArguments(arguments, 1);\n            args.unshift('context');\n            this.writer.functionCall('__helpers.' + methodName, args);\n        }\n        return this;\n    },\n    write: function (expression, options) {\n        if (!this.hasErrors()) {\n            if (options) {\n                if (options.escapeXml) {\n                    expression = this.getStaticHelperFunction('escapeXml', 'x') + '(' + expression + ')';\n                } else if (options.escapeXmlAttr) {\n                    expression = this.getStaticHelperFunction('escapeXmlAttr', 'xa') + '(' + expression + ')';\n                }\n            }\n            this.writer.write(expression);\n        }\n        return this;\n    },\n    incIndent: function () {\n        if (!this.hasErrors()) {\n            this.writer.incIndent.apply(this.writer, arguments);\n        }\n        return this;\n    },\n    decIndent: function () {\n        if (!this.hasErrors()) {\n            this.writer.decIndent.apply(this.writer, arguments);\n        }\n        return this;\n    },\n    code: function (code) {\n        if (!this.hasErrors()) {\n            this.writer.code(code);\n        }\n        return this;\n    },\n    statement: function (code) {\n        if (!this.hasErrors()) {\n            this.writer.statement(code);\n        }\n        return this;\n    },\n    line: function (code) {\n        if (!this.hasErrors()) {\n            this.writer.line(code);\n        }\n        return this;\n    },\n    indentStr: function (delta) {\n        return this.writer.indentStr(delta);\n    },\n    indent: function () {\n        if (!this.hasErrors()) {\n            this.writer.indent.apply(this.writer, arguments);\n        }\n        return this;\n    },\n    getPath: function () {\n        return this.path;\n    },\n    getOutput: function () {\n        if (this.hasErrors()) {\n            return '';\n        }\n        var out = new StringBuilder();\n        \n        var params = this.params;\n        if (params) {\n            params = ['context'].concat(params);\n        } else {\n            params = ['context'];\n        }\n        out.append('module.exports = function create(__helpers) {\\n');\n        //Write out the static variables\n        this.writer.flush();\n        this._writeVars(this.staticVars, out, INDENT);\n        out.append('\\n' + INDENT + 'return function render(data, context) {\\n');\n        //Write out the render variables\n        if (this.vars && this.vars.length) {\n            this._writeVars(this.vars, out, INDENT + INDENT);\n            out.append('\\n');\n        }\n        out.append(this.writer.getOutput());\n        out.append(INDENT + '};\\n}');\n        return out.toString();\n    },\n    setTemplateName: function (templateName) {\n        this.templateName = templateName;\n    },\n    makeExpression: function (expression) {\n        return this.compiler.makeExpression(expression);\n    },\n    hasExpression: function (str) {\n        return this.compiler.hasExpression(str);\n    },\n    isExpression: function (expression) {\n        return this.compiler.isExpression(expression);\n    },\n    parseExpression: function(str, listeners, options) {\n        return this.compiler.parseExpression(str, listeners, options);\n    },\n    parseAttribute: function(attr, types, options) {\n        return this.compiler.parseAttribute(attr, types, options);\n    },\n    getAttribute: function (name) {\n        return this.attributes[name];\n    },\n    setAttribute: function (name, value) {\n        this.attributes[name] = value;\n        return value;\n    },\n    hasErrors: function () {\n        return this.compiler.hasErrors();\n    },\n    addError: function (message, pos) {\n        this.compiler.addError(message, pos);\n    },\n    getErrors: function () {\n        return this.compiler.getErrors();\n    },\n    getNodeClass: function (namespace, localName) {\n        return this.compiler.getNodeClass(namespace, localName);\n    },\n    transformTree: function (node) {\n        this.compiler.transformTree(node, this);\n    },\n    getRequirePath: function(targetModuleFile) {\n        return this.compiler.getRequirePath(targetModuleFile);\n    },\n    INDENT: INDENT\n};\nmodule.exports = TemplateBuilder;","/home/travis/build/npmtest/node-npmtest-raptor-templates/node_modules/raptor-templates/compiler/parser.js":"require('raptor-polyfill/string/endsWith');\nvar ParseTreeBuilderHtml = require('./ParseTreeBuilderHtml');\nvar ParseTreeBuilderXml = require('./ParseTreeBuilderXml');\n\nfunction parse(src, filePath, taglibs) {\n    var ParseTreeBuilder = filePath.endsWith('.rxml') ?\n        ParseTreeBuilderXml :\n        ParseTreeBuilderHtml;\n\n    var parseTreeBuilder = new ParseTreeBuilder(taglibs);\n    \n    return parseTreeBuilder.parse(src, filePath);\n}\n\nexports.parse = parse;","/home/travis/build/npmtest/node-npmtest-raptor-templates/node_modules/raptor-templates/compiler/ParseTreeBuilderHtml.js":"var htmlparser = require(\"htmlparser2\");\nvar forEachEntry = require('raptor-util').forEachEntry;\n\nvar parserOptions  = {\n    recognizeSelfClosing: true,\n    recognizeCDATA: true,\n    lowerCaseTags: false,\n    lowerCaseAttributeNames: false,\n    xmlMode: false\n};\n\nfunction splitName(name) {\n    var parts = name.split(':');\n    if (parts.length === 1) {\n        return {\n            localName: name\n        };\n    }\n    else if (parts.length === 2) {\n        return {\n            prefix: parts[0],\n            localName: parts[1]\n        };\n    }\n}\n\nvar entities = {\n    quot: '\"',\n    lt: '<',\n    gt: '>',\n    amp: '&'\n};\n\nfunction decodeEntities(data) {\n    return data.replace(/&([^;]+);/g, function(match, entityName) {\n        return entities[entityName] || '${entity:' + entityName + '}';\n    });\n}\n\nfunction ParseTreeBuilderHtml(taglibs) {\n    ParseTreeBuilderHtml.$super.apply(this, arguments);\n    this.parser = null;\n}\n\nParseTreeBuilderHtml.prototype = {\n    getPos: function() {\n        return this.parser ? this.createPos(this.parser.startIndex) : null;\n    },\n\n    doParse: function (src, filePath) {\n\n        var _this = this;\n\n        // Create a pseudo root node\n        this.handleStartElement(splitName('c-template'), []);\n\n        var parser = this.parser = new htmlparser.Parser({\n            onopentag: function(name, attribs){\n                var el = splitName(name);\n\n                var attributes = [];\n                forEachEntry(attribs, function(name, value) {\n                    var attr = splitName(name);\n                    attr.value = decodeEntities(value);\n                    attributes.push(attr);\n                });\n\n                if (name.toLowerCase() === 'script') {\n                    attributes.push({\n                        localName: 'c-escape-xml',\n                        value: 'false'\n                    });\n                }\n\n                _this.handleStartElement(el, attributes);\n            },\n            onprocessinginstruction: function(name, data) {\n                _this.handleCharacters('${startTag:' + data + '}');\n                // _this.handleCharacters(data);\n                // _this.handleCharacters('${entity:gt}');\n            },\n            // oncdatastart: function() {\n            //     console.log('oncdatastart: ', arguments);\n            // },\n            // oncdataend: function() {\n            //     console.log('oncommentend: ', arguments);\n            // },\n            ontext: function(text){\n                _this.handleCharacters(decodeEntities(text));\n            },\n            onclosetag: function(name){\n                _this.handleEndElement();\n            }\n        }, parserOptions);\n        parser.write(src);\n        parser.end();\n\n        // End the pseudo root node:\n        _this.handleEndElement();\n    }\n};\n\nrequire('raptor-util').inherit(ParseTreeBuilderHtml, require('./ParseTreeBuilder'));\n\nmodule.exports = ParseTreeBuilderHtml;","/home/travis/build/npmtest/node-npmtest-raptor-templates/node_modules/raptor-templates/compiler/ParseTreeBuilder.js":"/*\n * Copyright 2011 eBay Software Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n'use strict';\n\nvar TextNode = require('./TextNode');\nvar ElementNode = require('./ElementNode');\nvar charProps = require('char-props');\n\n\n\nfunction Pos(filePath, line, column) {\n    this.filePath = filePath;\n    this.line = line;\n    this.column = column;\n}\n\nPos.prototype = {\n    toString: function() {\n        return this.filePath + \":\" + this.line + \":\" + this.column;\n    }\n};\n\nfunction ParseTreeBuilder(taglibs) {\n    this.taglibs = taglibs;\n\n    this.rootNode = null;\n    this.prevTextNode = null;\n    this.parentNode = null;\n    this.src = null;\n    this.filePath = null;\n    this.charProps = null;\n\n    this.nsStack = [];\n}\n\nParseTreeBuilder.prototype = {\n    createPos: function(line, column) {\n        if (arguments.length === 1) {\n            var index = arguments[0];\n            if (!this.charProps) {\n                this.charProps = charProps(this.src);\n            }\n            line = this.charProps.lineAt(index)+1;\n            column = this.charProps.columnAt(index);\n        }\n\n        return new Pos(this.filePath, line, column);\n    },\n    parse: function(src, filePath) {\n        this.src = src;\n        this.filePath = filePath;\n\n        this.doParse(src, filePath);\n\n        var rootNode = this.rootNode;\n\n        // Cleanup\n        this.src = null;\n        this.filePath = null;\n        this.charProps = null;\n        this.rootNode = null;\n        this.prevTextNode = null;\n        this.parentNode = null;\n        this.nsStack = [];\n\n        return rootNode;\n    },\n\n    handleCharacters: function(t) {\n        if (!this.parentNode) {\n            return;    //Some bad XML parsers allow text after the ending element...\n        }\n\n        if (this.prevTextNode) {\n            this.prevTextNode.text += t;\n        } else {\n            this.prevTextNode = new TextNode(t);\n            this.prevTextNode.pos = this.getPos();\n            this.parentNode.appendChild(this.prevTextNode);\n        }\n    },\n\n    handleStartElement: function(el, attributes) {\n        this.prevTextNode = null;\n\n        var namespaceMappings = this.nsStack.length ? Object.create(this.nsStack[this.nsStack.length-1]) : {};\n        this.nsStack.push(namespaceMappings);\n\n        attributes.forEach(function (attr) {\n            if (attr.prefix === 'xmlns') {\n                var nsPrefix = attr.localName;\n                var targetNS = attr.value;\n                namespaceMappings[nsPrefix] = targetNS;\n            }\n        }, this);\n\n        function getNS(node) {\n            if (node.namespace) {\n                return node.namespace;\n            } else if (node.prefix) {\n                if (node.prefix === 'xml') {\n                    return 'http://www.w3.org/XML/1998/namespace';\n                }\n                return namespaceMappings[node.prefix] || node.prefix;\n            }\n            else {\n                return '';\n            }\n        }\n        \n        var elNS = getNS(el);\n\n        var elementNode = new ElementNode(\n            el.localName,\n            elNS,\n            el.prefix);\n\n        elementNode.pos = this.getPos();\n\n        if (this.parentNode) {\n            this.parentNode.appendChild(elementNode);\n        } else {\n            \n            elementNode.setRoot(true);\n\n            if (!elNS && el.localName === 'template') {\n                elementNode.localName = 'c-template';\n            }\n\n            this.rootNode = elementNode;\n        }\n\n        attributes.forEach(function (attr) {\n            var attrNS = getNS(attr);\n            var attrLocalName = attr.localName;\n            var attrPrefix = attr.prefix;\n            elementNode.setAttributeNS(attrNS, attrLocalName, attr.value, attrPrefix);\n        }, this);\n        \n        this.parentNode = elementNode;\n    },\n\n    handleEndElement: function() {\n        this.prevTextNode = null;\n        this.parentNode = this.parentNode.parentNode;\n        this.nsStack.pop();\n    },\n\n    getRootNode: function () {\n        return this.rootNode;\n    }\n};\n\nmodule.exports = ParseTreeBuilder;","/home/travis/build/npmtest/node-npmtest-raptor-templates/node_modules/raptor-templates/compiler/ParseTreeBuilderXml.js":"var sax = require(\"sax\");\nvar extend = require('raptor-util/extend');\n\nfunction ParseTreeBuilderXml(taglibs) {\n    ParseTreeBuilderXml.$super.apply(this, arguments);\n    this.parser = null;\n    this.filePath = null;\n}\n\nParseTreeBuilderXml.prototype = {\n    getPos: function() {\n        var parser = this.parser;\n        var filePath = this.filePath;\n        \n        var line = parser.line + 1;\n        \n        return {\n            line: line,\n            column: parser.column,\n            filePath: filePath,\n            toString: function() {\n                return this.filePath + \":\" + this.line + \":\" + this.column;\n            }\n            \n        };\n    },\n\n    doParse: function (src, filePath) {\n        \n        this.filePath = filePath;\n        var parser = this.parser = sax.parser(true /*strict*/, {\n            trim: false,\n            normalize: false,\n            lowercasetags: false,\n            xmlns: true\n        });\n\n        var _this = this;\n    \n        extend(parser, {\n            onerror: function(e) {\n                throw e;\n            },\n            \n            ontext: function(text) {\n                text = text.replace(/\\r\\n|\\r/g, \"\\n\");\n                _this.handleCharacters(text);\n            },\n\n            oncdata: function(text) {\n                text = text.replace(/\\r\\n|\\r/g, \"\\n\");\n                _this.handleCharacters(text);\n            },\n            \n            onopentag: function (node) {\n                var el = {\n                    namespace: node.uri,\n                    prefix: node.prefix,\n                    localName: node.local\n                };\n\n                var attributes = Object.keys(node.attributes).map(function(attrName) {\n                    var attr = node.attributes[attrName];\n                    return {\n                        namespace: attr.uri,\n                        localName: attr.local,\n                        prefix: attr.prefix,\n                        value: attr.value\n                    };\n                });\n\n                _this.handleStartElement(el, attributes);\n            },\n\n            \n            \n            onclosetag: function () {\n                _this.handleEndElement();\n            },\n\n            oncomment: function (comment) {\n            }\n        });\n\n        parser.write(src).close();\n    }\n};\n\nrequire('raptor-util').inherit(ParseTreeBuilderXml, require('./ParseTreeBuilder'));\n\nmodule.exports = ParseTreeBuilderXml;","/home/travis/build/npmtest/node-npmtest-raptor-templates/node_modules/raptor-templates/compiler/taglibs/index.js":"exports.Taglib = require('./Taglib');\nexports.loader = require('./taglib-loader');\nexports.lookup = require('./taglib-lookup');\nexports.buildLookup = exports.lookup.buildLookup;\nexports.registerTaglib = exports.lookup.registerTaglib;\nexports.excludeDir = exports.lookup.excludeDir;\n","/home/travis/build/npmtest/node-npmtest-raptor-templates/node_modules/raptor-templates/compiler/taglibs/Taglib.js":"/*\n * Copyright 2011 eBay Software Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n'use strict';\nvar forEachEntry = require('raptor-util').forEachEntry;\nvar ok = require('assert').ok;\nvar makeClass = require('raptor-util').makeClass;\n\nfunction Taglib(id) {\n    ok(id, '\"id\" expected');\n    this.id = id;\n    this.dirname = null;\n    this.tags = {};\n    this.textTransformers = [];\n    this.attributes = {};\n    this.patternAttributes = [];\n    this.inputFilesLookup = {};\n}\n\nTaglib.prototype = {\n\n    addInputFile: function(path) {\n        this.inputFilesLookup[path] = true;\n    },\n\n    getInputFiles: function() {\n        return Object.keys(this.inputFilesLookup);\n    },\n\n    addAttribute: function (attribute) {\n        if (attribute.pattern) {\n            this.patternAttributes.push(attribute);\n        } else if (attribute.name) {\n            this.attributes[attribute.name] = attribute;\n        } else {\n            throw new Error('Invalid attribute: ' + require('util').inspect(attribute));\n        }\n    },\n    getAttribute: function (name) {\n        var attribute = this.attributes[name];\n        if (!attribute) {\n            for (var i = 0, len = this.patternAttributes.length; i < len; i++) {\n                var patternAttribute = this.patternAttributes[i];\n                if (patternAttribute.pattern.test(name)) {\n                    attribute = patternAttribute;\n                }\n            }\n        }\n        return attribute;\n    },\n    addTag: function (tag) {\n        ok(arguments.length === 1, 'Invalid args');\n        ok(tag.name, '\"tag.name\" is required');\n        this.tags[tag.name] = tag;\n        tag.taglibId = this.id;\n    },\n    addTextTransformer: function (transformer) {\n        this.textTransformers.push(transformer);\n    },\n    forEachTag: function (callback, thisObj) {\n        forEachEntry(this.tags, function (key, tag) {\n            callback.call(thisObj, tag);\n        }, this);\n    }\n};\n\nTaglib.Tag = makeClass({\n    $init: function(taglib) {\n        this.taglibId = taglib ? taglib.id : null;\n        this.renderer = null;\n        this.nodeClass = null;\n        this.template = null;\n        this.attributes = {};\n        this.transformers = {};\n        this.nestedVariables = {};\n        this.importedVariables = {};\n        this.patternAttributes = [];\n    },\n    inheritFrom: function (superTag) {\n        var subTag = this;\n        /*\n         * Have the sub tag inherit any properties from the super tag that are not in the sub tag\n         */\n        forEachEntry(superTag, function (k, v) {\n            if (subTag[k] === undefined) {\n                subTag[k] = v;\n            }\n        });\n        function inheritProps(sub, sup) {\n            forEachEntry(sup, function (k, v) {\n                if (!sub[k]) {\n                    sub[k] = v;\n                }\n            });\n        }\n        [\n            'attributes',\n            'transformers',\n            'nestedVariables',\n            'importedVariables'\n        ].forEach(function (propName) {\n            inheritProps(subTag[propName], superTag[propName]);\n        });\n        subTag.patternAttributes = superTag.patternAttributes.concat(subTag.patternAttributes);\n    },\n    forEachVariable: function (callback, thisObj) {\n        forEachEntry(this.nestedVariables, function (key, variable) {\n            callback.call(thisObj, variable);\n        });\n    },\n    forEachImportedVariable: function (callback, thisObj) {\n        forEachEntry(this.importedVariables, function (key, importedVariable) {\n            callback.call(thisObj, importedVariable);\n        });\n    },\n    forEachTransformer: function (callback, thisObj) {\n        forEachEntry(this.transformers, function (key, transformer) {\n            callback.call(thisObj, transformer);\n        });\n    },\n    hasTransformers: function () {\n        /*jshint unused:false */\n        for (var k in this.transformers) {\n            if (this.transformers.hasOwnProperty(k)) {\n                return true;    \n            }\n            \n        }\n        return false;\n    },\n    addAttribute: function (attr) {\n        if (attr.pattern) {\n            this.patternAttributes.push(attr);\n        } else {\n            if (attr.name === '*') {\n                attr.dynamicAttribute = true;\n\n                if (attr.targetProperty === null || attr.targetProperty === '') {\n                    attr.targetProperty = null;\n                    \n                }\n                else if (!attr.targetProperty) {\n                    attr.targetProperty = '*';\n                }\n            }\n\n            this.attributes[attr.name] = attr;\n        }\n    },\n    toString: function () {\n        return '[Tag: <' + this.name + '@' + this.taglibId + '>]';\n    },\n    forEachAttribute: function (callback, thisObj) {\n        for (var attrName in this.attributes) {\n            if (this.attributes.hasOwnProperty(attrName)) {\n                callback.call(thisObj, this.attributes[attrName]);    \n            }\n        }\n    },\n    addNestedVariable: function (nestedVariable) {\n        var key = nestedVariable.nameFromAttribute ? 'attr:' + nestedVariable.nameFromAttribute : nestedVariable.name;\n        this.nestedVariables[key] = nestedVariable;\n    },\n    addImportedVariable: function (importedVariable) {\n        var key = importedVariable.targetProperty;\n        this.importedVariables[key] = importedVariable;\n    },\n    addTransformer: function (transformer) {\n        var key = transformer.path;\n        transformer.taglibId = this.taglibId;\n        this.transformers[key] = transformer;\n    }\n});\n\nTaglib.Attribute = makeClass({\n    $init: function(name) {\n        this.name = name;\n        this.type = null;\n        this.required = false;\n        this.type = 'string';\n        this.allowExpressions = true;\n    }\n});\n\nTaglib.Property = makeClass({\n    $init: function() {\n        this.name = null;\n        this.type = 'string';\n        this.value = undefined;\n    }\n});\n\nTaglib.NestedVariable = makeClass({\n    $init: function() {\n        this.name = null;\n    }\n});\n\nTaglib.ImportedVariable = makeClass({\n    $init: function() {\n        this.targetProperty = null;\n        this.expression = null;\n    }\n});\n\nvar nextTransformerId = 0;\n\nTaglib.Transformer = makeClass({\n    $init: function() {\n        this.id = nextTransformerId++;\n        this.name = null;\n        this.tag = null;\n        this.path = null;\n        this.priority = null;\n        this._func = null;\n        this.properties = {};\n    },\n\n    getFunc: function () {\n        if (!this.path) {\n            throw new Error('Transformer path not defined for tag transformer (tag=' + this.tag + ')');\n        }\n\n        if (!this._func) {\n            var transformer = require(this.path);\n\n            if (typeof transformer === 'function') {\n                if (transformer.prototype.process) {\n                    var Clazz = transformer;\n                    var instance = new Clazz();\n                    instance.id = this.id;\n                    this._func = instance.process.bind(instance);\n                } else {\n                    this._func = transformer;\n                }\n            } else {\n                this._func = transformer.process || transformer.transform;\n            }\n        }\n        return this._func;\n    },\n    toString: function () {\n        return '[Taglib.Transformer: ' + this.path + ']';\n    }\n});\n\nmodule.exports = Taglib;","/home/travis/build/npmtest/node-npmtest-raptor-templates/node_modules/raptor-templates/compiler/taglibs/taglib-loader.js":"var fs = require('fs');\nvar ok = require('assert').ok;\nvar nodePath = require('path');\nvar Taglib = require('./Taglib');\nvar cache = {};\nvar forEachEntry = require('raptor-util').forEachEntry;\nvar raptorRegexp = require('raptor-regexp');\nvar tagDefFromCode = require('./tag-def-from-code');\nvar resolve = require('raptor-modules/resolver').serverResolveRequire;\nvar propertyHandlers = require('property-handlers');\n\nfunction createDefaultTagDef() {\n    return {\n            attributes: {\n                '*': {\n                    type: 'string',\n                    targetProperty: null\n                }\n            }\n         };\n}\n\nfunction buildAttribute(attr, attrProps, path) {\n\n\n    propertyHandlers(attrProps, {\n        type: function(value) {\n            attr.type = value;\n        },\n        targetProperty: function(value) {\n            attr.targetProperty = value;\n        },\n        defaultValue: function(value) {\n            attr.defaultValue = value;\n        },\n        pattern: function(value) {\n            if (value === true) {\n                var patternRegExp = raptorRegexp.simple(attr.name);\n                attr.pattern = patternRegExp;\n            }\n        },\n        allowExpressions: function(value) {\n            attr.allowExpressions = value;\n        },\n        preserveName: function(value) {\n            attr.preserveName = value;\n        },\n        required: function(value) {\n            attr.required = value === true;\n        },\n        removeDashes: function(value) {\n            attr.removeDashes = value === true;\n        },\n        description: function() {\n            \n        }\n    }, path);\n\n    return attr;\n}\n\nfunction handleAttributes(value, parent, path) {\n    forEachEntry(value, function(attrName, attrProps) {\n        var attr = new Taglib.Attribute(attrName);\n\n        if (attrProps == null) {\n            attrProps = {\n                type: 'string'\n            };\n        } else if (typeof attrProps === 'string') {\n            attrProps = {\n                type: attrProps\n            };\n        }\n\n        buildAttribute(attr, attrProps, '\"' + attrName + '\" attribute as part of ' + path);\n\n        parent.addAttribute(attr);\n    });\n}\n\nfunction buildTag(tagObject, path, taglib, dirname) {\n    ok(tagObject);\n    ok(typeof path === 'string');\n    ok(taglib);\n    ok(typeof dirname === 'string');\n\n    var tag = new Taglib.Tag(taglib);\n\n    if (tagObject.attributes == null) {\n        // allow any attributes if no attributes are declared\n        tagObject.attributes = {\n            '*': 'string'\n        };\n    }\n\n    propertyHandlers(tagObject, {\n        name: function(value) {\n            tag.name = value;\n        },\n\n        renderer: function(value) {\n            var path = resolve(value, dirname);\n            if (!fs.existsSync(path)) {\n                throw new Error('Renderer at path \"' + path + '\" does not exist.');\n            }\n\n            tag.renderer = path;\n        },\n        template: function(value) {\n            var path = nodePath.resolve(dirname, value);\n            if (!fs.existsSync(path)) {\n                throw new Error('Template at path \"' + path + '\" does not exist.');\n            }\n\n            tag.template = path;\n        },\n        attributes: function(value) {\n            handleAttributes(value, tag, path);\n        },\n        nodeClass: function(value) {\n            var path = resolve(value, dirname);\n            if (!fs.existsSync(path)) {\n                throw new Error('Node module at path \"' + path + '\" does not exist.');\n            }\n\n            tag.nodeClass = path;\n        },\n        transformer: function(value) {\n            var transformer = new Taglib.Transformer();\n\n            if (typeof value === 'string') {\n                value = {\n                    path: value\n                };\n            }\n\n            propertyHandlers(value, {\n                path: function(value) {\n                    var path = resolve(value, dirname);\n                    if (!fs.existsSync(path)) {\n                        throw new Error('Transformer at path \"' + path + '\" does not exist.');\n                    }\n\n                    transformer.path = path;\n                },\n\n                priority: function(value) {\n                    transformer.priority = value;\n                },\n\n                name: function(value) {\n                    transformer.name = value;\n                },\n\n                properties: function(value) {\n                    var properties = transformer.properties || (transformer.properties = {});\n                    for (var k in value) {\n                        if (value.hasOwnProperty(k)) {\n                            properties[k] = value[k];\n                        }\n                    }\n                }\n\n            }, 'transformer in ' + path);\n\n            ok(transformer.path, '\"path\" is required for transformer');\n\n            tag.addTransformer(transformer);\n        },\n\n        'var': function(value) {\n            tag.addNestedVariable({\n                name: value\n            });\n        },\n        vars: function(value) {\n            if (value) {\n                value.forEach(function(v, i) {\n                    var nestedVariable;\n\n                    if (typeof v === 'string') {\n                        nestedVariable = {\n                            name: v\n                        };\n                    } else {\n                        nestedVariable = {};\n\n                        propertyHandlers(v, {\n                            \n                            name: function(value) {\n                                nestedVariable.name = value;\n                            },\n\n                            nameFromAttribute: function(value) {\n                                nestedVariable.nameFromAttribute = value;\n                            }\n\n                        }, 'var at index ' + i);\n\n                        if (!nestedVariable.name && !nestedVariable.nameFromAttribute) {\n                            throw new Error('The \"name\" or \"name-from-attribute\" attribute is required for a nested variable');\n                        }\n                    }\n\n                    tag.addNestedVariable(nestedVariable);\n                });\n            }\n        },\n        importVar: function(value) {\n            forEachEntry(value, function(varName, varValue) {\n                var importedVar = {\n                    targetProperty: varName\n                };\n\n                var expression = varValue;\n\n                if (!expression) {\n                    expression = varName;\n                }\n                else if (typeof expression === 'object') {\n                    expression = expression.expression;\n                }\n\n                if (!expression) {\n                    throw new Error('Invalid \"import-var\": ' + require('util').inspect(varValue));\n                }\n\n                importedVar.expression = expression;\n                tag.addImportedVariable(importedVar);\n            });\n        }\n    }, path);\n\n    return tag;\n}\n\n/**\n * @param {String} tagsConfigPath path to tag definition file\n * @param {String} tagsConfigDirname path to directory of tags config file (should be path.dirname(tagsConfigPath))\n * @param {String} dir the path to directory to scan\n * @param {String} taglib the taglib that is being loaded\n */\nfunction scanTagsDir(tagsConfigPath, tagsConfigDirname, dir, taglib) {\n    dir = nodePath.resolve(tagsConfigDirname, dir);\n    var children = fs.readdirSync(dir);\n\n    for (var i=0, len=children.length; i<len; i++) {\n        var childFilename = children[i];\n        if (childFilename === 'node_modules') {\n            continue;\n        }\n        var tagDirname = nodePath.join(dir, childFilename);\n        var tagFile = nodePath.join(dir, childFilename, 'raptor-tag.json');\n        var tag = null;\n        var rendererFile = nodePath.join(dir, childFilename, 'renderer.js');\n        var templateFile = nodePath.join(dir, childFilename, 'template.rhtml');\n        var tagDef = null;\n\n        // Record dependencies so that we can check if a template is up-to-date\n        taglib.addInputFile(tagFile);\n        taglib.addInputFile(rendererFile);\n\n        if (fs.existsSync(tagFile)) {\n            // raptor-tag.json exists in the directory, use that as the tag definition\n            tagDef = JSON.parse(fs.readFileSync(tagFile, {encoding: 'utf8'}));\n            if (!tagDef.renderer || !tagDef.template) {\n                if (fs.existsSync(rendererFile)) {\n                    tagDef.renderer = rendererFile;\n                } else if (fs.existsSync(templateFile)) {\n                    tagDef.template = templateFile;\n                } else {\n                    throw new Error('Invalid tag. Neither a renderer or a template was found for tag.');\n                }\n            }\n\n            tag = buildTag(tagDef, tagsConfigPath, taglib, tagDirname);\n            tag.name = childFilename;\n            taglib.addTag(tag);\n        } else {\n            // raptor-tag.json does *not* exist... checking for a 'renderer.js'\n            \n\n            if (fs.existsSync(rendererFile)) {\n                var rendererCode = fs.readFileSync(rendererFile, {encoding: 'utf8'});\n                tagDef = tagDefFromCode.extractTagDef(rendererCode);\n                if (!tagDef) {\n                     tagDef = createDefaultTagDef();\n                }\n\n                tagDef.renderer  = rendererFile;\n                tag = buildTag(tagDef, tagsConfigPath, taglib, tagDirname);\n                tag.name = childFilename;\n                taglib.addTag(tag);\n            } else if (fs.existsSync(templateFile)) {\n                var templateCode = fs.readFileSync(templateFile, {encoding: 'utf8'});\n                tagDef = tagDefFromCode.extractTagDef(templateCode);\n                if (!tagDef) {\n                     tagDef = createDefaultTagDef();\n                }\n\n                tagDef.template = templateFile;\n            }\n\n            if (tagDef) {\n                tag = buildTag(tagDef, tagsConfigPath, taglib, tagDirname);\n                tag.name = childFilename;\n                taglib.addTag(tag);\n            }\n        }\n    }\n}\n\nfunction load(path) {\n    if (cache[path]) {\n        return cache[path];\n    }\n\n    var src = fs.readFileSync(path, {encoding: 'utf8'});\n    var taglib = new Taglib(path);\n    taglib.addInputFile(path);\n    var dirname = nodePath.dirname(path);\n\n    var taglibObject;\n\n    try {\n        taglibObject = JSON.parse(src);\n    }\n    catch(e) {\n        throw new Error('Unable to parse taglib JSON at path \"' + path + '\". Exception: ' + e);\n    }\n\n    propertyHandlers(taglibObject, {\n        attributes: function(value) {\n            handleAttributes(value, taglib, path);\n        },\n        tags: function(tags) {\n            forEachEntry(tags, function(tagName, path) {\n                ok(path, 'Invalid tag definition for \"' + tagName + '\"');\n                var tagObject;\n\n                var tagDirname;\n\n                if (typeof path === 'string') {\n                    path = nodePath.resolve(dirname, path);\n                    taglib.addInputFile(path);\n                    \n                    tagDirname = nodePath.dirname(path);\n                    if (!fs.existsSync(path)) {\n                        throw new Error('Tag at path \"' + path + '\" does not exist. Taglib: ' + taglib.id);\n                    }\n\n                    var tagJSON = fs.readFileSync(path, {encoding: 'utf8'});\n\n                    try {\n                        tagObject = JSON.parse(tagJSON);\n                    }\n                    catch(e) {\n                        throw new Error('Unable to parse tag JSON for tag at path \"' + path + '\"');\n                    }\n                } else {\n                    tagDirname = dirname; // Tag is in the same taglib file\n                    tagObject = path;\n                    path = '<' + tagName + '> tag in ' + taglib.id;\n                }\n\n\n                var tag = buildTag(tagObject, path, taglib, tagDirname);\n                if (tag.name === undefined) {\n                    tag.name = tagName;\n                }\n                taglib.addTag(tag);\n            });\n        },\n        tagsDir: function(dir) {\n\n            if (Array.isArray(dir)) {\n                for (var i = 0; i < dir.length; i++) {\n                    scanTagsDir(path, dirname, dir[i], taglib);\n                }\n            } else {\n                scanTagsDir(path, dirname, dir, taglib);\n            }\n        },\n        textTransformer: function(value) {\n            var transformer = new Taglib.Transformer();\n\n            if (typeof value === 'string') {\n                value = {\n                    path: value\n                };\n            }\n\n            propertyHandlers(value, {\n                path: function(value) {\n                    var path = resolve(value, dirname);\n                    if (!fs.existsSync(path)) {\n                        throw new Error('Transformer at path \"' + path + '\" does not exist.');\n                    }\n\n                    transformer.path = path;\n                }\n\n            }, 'text-transformer in ' + path);\n\n            ok(transformer.path, '\"path\" is required for transformer');\n\n            taglib.addTextTransformer(transformer);\n        }\n    }, path);\n\n    taglib.id = path;\n\n    cache[path] = taglib;\n\n    return taglib;\n}\n\nexports.load = load;\n","/home/travis/build/npmtest/node-npmtest-raptor-templates/node_modules/raptor-templates/compiler/taglibs/tag-def-from-code.js":"// Rather than using a full-blown JavaScript parser, we are going to use a few regular expressions\n// to tokenize the code and find what we are interested in\nvar tagStartRegExp = /(^\\s*(?:(?:exports.(?:tag|TAG))|(?:TAG))\\s*=\\s*)\\{/m;\n\n// Tokens: \"<string>\", '<string>', /*<some comment*/, //<single line comment>, {, }, ;\nvar tokensRegExp = /\"(?:[^\"]|\\\\\")*\"|'(?:[^'])|(\\/\\*([^*]|[\\r\\n]|(\\*+([^*/]|[\\r\\n])))*\\*+\\/)|(\\/\\/.*)|[\\{\\};]/g;\n\nfunction extractTagDef(code) {\n\n    var startMatches = tagStartRegExp.exec(code);\n    \n    var tagDefStart;\n    var tagDefEnd;\n\n    if (startMatches) {\n        tagDefStart = startMatches.index + startMatches[1].length;\n        var nextTokenMatches;\n        tokensRegExp.lastIndex = tagDefStart;\n        var depth = 0;\n\n        while ((nextTokenMatches = tokensRegExp.exec(code))) {\n            if (nextTokenMatches[0] === '{') {\n                depth++;\n                continue;\n            } else if (nextTokenMatches[0] === '}') {\n                if (--depth === 0) {\n                    tagDefEnd = tokensRegExp.lastIndex;\n                    break;\n                }\n            }\n            else if (nextTokenMatches[0] === ';') {\n                tagDefEnd = nextTokenMatches.index;\n                break;\n            }\n        }\n\n        if (tagDefStart != null && tagDefEnd != null) {\n            var jsTagDef = code.substring(tagDefStart, tagDefEnd);\n            var tagDefObject = eval('(' + jsTagDef + ')');\n            return tagDefObject;\n        }\n    } else {\n        return null;\n    }    \n}\n\nexports.extractTagDef = extractTagDef;","/home/travis/build/npmtest/node-npmtest-raptor-templates/node_modules/raptor-templates/compiler/taglibs/taglib-lookup.js":"var nodePath = require('path');\nvar fs = require('fs');\nvar taglibLoader = require('./taglib-loader');\nvar existsCache = {};\nvar TaglibLookup = require('./TaglibLookup');\n\nexports.registeredTaglibs = [];\n\nvar lookupCache = {};\nvar discoverCache = {};\nvar excludedDirs = {};\nvar taglibsByPath = {};\n\nfunction existsCached(path) {\n    var exists = existsCache[path];\n    if (exists === undefined) {\n        exists = fs.existsSync(path);\n        existsCache = exists;\n    }\n    return exists;\n}\n\nfunction tryDir(dirname, discovered) {\n    var taglibPath = nodePath.join(dirname, 'raptor-taglib.json');\n    if (existsCached(taglibPath)) {\n        var taglib = taglibLoader.load(taglibPath);\n\n        discovered.push(taglib);\n    }\n}\n\nfunction tryNodeModules(parent, discovered) {\n    if (nodePath.basename(parent) === 'node_modules') {\n        return;\n    }\n\n    var nodeModulesDir = nodePath.join(parent, 'node_modules');\n    \n    var taglibs = taglibsByPath[nodeModulesDir];\n    if (taglibs !== undefined) {\n        if (taglibs !== null) {\n            for (var i = 0, len = taglibs.length; i < len; i++) {\n                discovered.push(taglibs[i]);\n            }\n        }\n        return;\n    }\n\n    if (existsCached(nodeModulesDir)) {\n        taglibs = [];\n        var children = fs.readdirSync(nodeModulesDir);\n        children.forEach(function(moduleDirBasename) {\n            var moduleDir = nodePath.join(nodeModulesDir, moduleDirBasename);\n            var taglibPath = nodePath.join(moduleDir, 'raptor-taglib.json');\n\n\n            if (existsCached(taglibPath)) {\n                var taglib = taglibLoader.load(taglibPath);\n                taglib.moduleName = moduleDirBasename;\n                taglibs.push(taglib);\n                discovered.push(taglib);\n            }\n        });\n\n        taglibsByPath[nodeModulesDir] = taglibs.length ? taglibs : null;\n    } else {\n        taglibsByPath[nodeModulesDir] = null;\n    }\n}\n\nfunction discoverHelper(dirname, discovered) {\n\n    if (!excludedDirs[dirname]) {\n        tryDir(dirname, discovered);\n        tryNodeModules(dirname, discovered);\n    }\n\n    var parent = nodePath.dirname(dirname);\n    if (parent && parent !== dirname) {\n        // TODO: Don't use recursion (there's a simpler way)\n        discoverHelper(parent, discovered);\n    }\n}\n\nfunction discover(dirname) {\n\n    var discovered = discoverCache[dirname];\n    if (discovered) {\n        return discovered;\n    }\n\n    discovered = [];\n\n    discoverHelper(dirname, discovered);\n\n    discovered = discovered.concat(exports.registeredTaglibs);\n    \n    discoverCache[dirname] = discovered;\n\n    return discovered;\n}\n\nfunction buildLookup(dirname) {\n\tvar taglibs = discover(dirname);\n\n\tvar lookupCacheKey = taglibs\n\t\t.map(function(taglib) {\n\t\t\treturn taglib.id;\n\t\t})\n\t\t.join(',');\n\n\tvar lookup = lookupCache[lookupCacheKey];\n\tif (lookup === undefined) {\n\t\tlookup = new TaglibLookup();\n\t\t\n        for (var i=taglibs.length-1; i>=0; i--) {\n\t\t\tlookup.addTaglib(taglibs[i]);\n\t\t}\n\n\t\tlookupCache[lookupCacheKey] = lookup;\n\t}\n\n\treturn lookup;\n}\n\nfunction registerTaglib(taglib) {\n    if (typeof taglib === 'string') {\n        taglib = taglibLoader.load(taglib);\n    }\n\n    exports.registeredTaglibs.push(taglib);\n}\n\nfunction excludeDir(dirname) {\n    excludedDirs[dirname] = true;\n}\n\nexports.excludeDir = excludeDir;\nexports.registerTaglib = registerTaglib;\nexports.buildLookup = buildLookup;","/home/travis/build/npmtest/node-npmtest-raptor-templates/node_modules/raptor-templates/compiler/taglibs/TaglibLookup.js":"var ok = require('assert').ok;\nvar createError = require('raptor-util').createError;\n\nfunction transformerComparator(a, b) {\n    a = a.priority;\n    b = b.priority;\n\n    if (a == null) {\n        a = Number.MAX_VALUE;\n    }\n\n    if (b == null) {\n        b = Number.MAX_VALUE;\n    }\n\n    return a - b;\n}\n\nfunction merge(target, source) {\n    for (var k in source) {\n        if (source.hasOwnProperty(k)) {\n            if (target[k] && typeof target[k] === 'object' &&\n                source[k] && typeof source[k] === 'object') {\n\n                if (Array.isArray(target[k]) || Array.isArray(source[k])) {\n\n                    var targetArray = target[k];\n                    var sourceArray = source[k];\n                    \n\n                    if (!Array.isArray(targetArray)) {\n                        targetArray = [targetArray];\n                    }\n\n                    if (!Array.isArray(sourceArray)) {\n                        sourceArray = [sourceArray];\n                    }\n\n                    target[k] = [].concat(targetArray).concat(sourceArray);\n                } else {\n                    var Ctor = target[k].constructor;\n                    var newTarget = new Ctor();\n                    merge(newTarget, target[k]);\n                    merge(newTarget, source[k]);\n                    target[k] = newTarget;\n                }\n                \n            } else {\n                target[k] = source[k];\n            }\n        }\n    }\n\n    return target;\n}\n\nfunction TaglibLookup() {\n    this.merged = {};\n    this.taglibsById = {};\n    this._inputFiles = null;\n}\n\nTaglibLookup.prototype = {\n\n\n    addTaglib: function (taglib) {\n        ok(taglib, '\"taglib\" is required');\n        ok(taglib.id, '\"taglib.id\" expected');\n\n        if (this.taglibsById.hasOwnProperty(taglib.id)) {\n            return;\n        }\n\n        this.taglibsById[taglib.id] = taglib;\n\n        merge(this.merged, taglib);\n    },\n\n    getTag: function (element) {\n        if (typeof element === 'string') {\n            element = {\n                localName: element\n            };\n        }\n        var tags = this.merged.tags;\n        if (!tags) {\n            return;\n        }\n\n        var tagKey = element.namespace ? element.namespace + ':' + element.localName : element.localName;\n        return tags[tagKey];\n    },\n\n    getAttribute: function (element, attr) {\n\n        if (typeof element === 'string') {\n            element = {\n                localName: element\n            };\n        }\n\n        if (typeof attr === 'string') {\n            attr = {\n                localName: attr\n            };\n        }\n\n        var tags = this.merged.tags;\n        if (!tags) {\n            return;\n        }\n\n        var tagKey = element.namespace ? element.namespace + ':' + element.localName : element.localName;\n        var attrKey = attr.namespace ? attr.namespace + ':' + attr.localName : attr.localName;\n\n        function findAttributeForTag(tag, attributes, attrKey) {\n            // try by exact match first\n            var attribute = attributes[attrKey];\n            if (attribute === undefined && attrKey !== '*') {\n                if (tag.patternAttributes) {\n                    // try searching by pattern\n                    for (var i = 0, len = tag.patternAttributes.length; i < len; i++) {\n                        var patternAttribute = tag.patternAttributes[i];\n                        if (patternAttribute.pattern.test(attrKey)) {\n                            attribute = patternAttribute;\n                            break;\n                        }\n                    }\n                }\n            }\n\n            return attribute;\n        }\n\n        var globalAttributes = this.merged.attributes;\n\n        function tryAttribute(tagKey, attrKey) {\n            var tag = tags[tagKey];\n            if (!tag) {\n                return undefined;\n            }\n\n            return findAttributeForTag(tag, tag.attributes, attrKey) ||\n                   findAttributeForTag(tag, globalAttributes, attrKey);\n        }\n\n        var attrDef = tryAttribute(tagKey, attrKey) || // Look for an exact match at the tag level\n            tryAttribute('*', attrKey) || // If not there, see if there is a exact match on the attribute name for attributes that apply to all tags\n            tryAttribute(tagKey, '*'); // Otherwise, see if there is a splat attribute for the tag\n\n        return attrDef;\n    },\n\n    forEachNodeTransformer: function (node, callback, thisObj) {\n        /*\n         * Based on the type of node we have to choose how to transform it\n         */\n        if (node.isElementNode()) {\n            this.forEachTagTransformer(node, callback, thisObj);\n        } else if (node.isTextNode()) {\n            this.forEachTextTransformer(callback, thisObj);\n        }\n    },\n    forEachTagTransformer: function (element, callback, thisObj) {\n        if (typeof element === 'string') {\n            element = {\n                localName: element\n            };\n        }\n\n        var tagKey = element.namespace ? element.namespace + ':' + element.localName : element.localName;\n        /*\n         * If the node is an element node then we need to find all matching\n         * transformers based on the URI and the local name of the element.\n         */\n\n        var transformers = [];\n        \n        function addTransformer(transformer) {\n            if (!transformer || !transformer.getFunc) {\n                throw createError(new Error('Invalid transformer'));\n            }\n\n            transformers.push(transformer);\n        }\n\n        /*\n         * Handle all of the transformers for all possible matching transformers.\n         *\n         * Start with the least specific and end with the most specific.\n         */\n\n        if (this.merged.tags[tagKey]) {\n            this.merged.tags[tagKey].forEachTransformer(addTransformer);\n        }\n\n        if (this.merged.tags['*']) {\n            this.merged.tags['*'].forEachTransformer(addTransformer);\n        }\n\n        transformers.sort(transformerComparator);\n\n        transformers.forEach(callback, thisObj);\n    },\n    forEachTextTransformer: function (callback, thisObj) {\n        this.merged.textTransformers.sort(transformerComparator);\n        this.merged.textTransformers.forEach(callback, thisObj);\n    },\n    getInputFiles: function() {\n        if (!this._inputFiles) {\n            var inputFilesSet = {};\n\n            for (var taglibId in this.taglibsById) {\n                if (this.taglibsById.hasOwnProperty(taglibId)) {\n\n                    var taglibInputFiles = this.taglibsById[taglibId].getInputFiles();\n                    var len = taglibInputFiles.length;\n                    if (len) {\n                        for (var i=0; i<len; i++) {\n                            inputFilesSet[taglibInputFiles[i]] = true;\n                        }\n                    }\n                }\n            }\n\n            this._inputFiles = Object.keys(inputFilesSet);\n        }\n\n        return this._inputFiles;\n    },\n\n    toString: function() {\n        return 'lookup: ' + this.getInputFiles().join(', ');\n    }\n};\nmodule.exports = TaglibLookup;","/home/travis/build/npmtest/node-npmtest-raptor-templates/node_modules/raptor-templates/compiler/attribute-parser.js":"/*\n * Copyright 2011 eBay Software Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Utility class to support sub-attributes in an XML attribute. Each sub-attribute must\n * be separated by a semicolon. Within each sub-attribute, the name/value pair must\n * be split using an equal sign. However, the name for the first sub-attribute\n * is optional and a default name can be provided when reading the sub-attributes.\n *\n * <p>\n * Sub-attribute format:\n * (<attr-value>)?(<attr-name>=<attr-value>;)*(<attr-name>=<attr-value>)\n *\n *\n *\n */\n'use strict';\nvar createError = require('raptor-util').createError;\nvar strings = require('raptor-strings');\nvar TypeConverter = require('./TypeConverter');\nvar regExp = /\"(?:[^\"]|\\\\\")*\"|'(?:[^']|\\\\')*'|==|===|[;=]/g;\n\n/**\n * Parses the provided string to find the sub-attributes that it contains.\n * The parsed output can be either returned as an array or a map. By default,\n * the parsed output is returned as a map where each property corresponds\n * to a sub-attribute. However, if the order of the sub-attributes is important\n * then the \"ordered\" option can be set to \"true\" and\n * an array will instead be returned where each element in the array is an object\n * with a name and value property that corresponds to the matching sub-attribute.\n *\n * <p>\n * Supported options:\n * <ul>\n *  <li>ordered (boolean, defaults to \"false\") - If true then an array is returned (see above). Otherwise, an object is returned.\n * </ul>\n *\n * @memberOf raptor/templating/compiler$AttributeSplitter\n * @param attr {String} The attribute to split\n * @param types {Object} Type definitions for the possible sub-attributes.\n * @param options\n * @returns\n */\nexports.parse = function (attr, types, options) {\n    if (!options) {\n        options = {};\n    }\n    var partStart = 0;\n    var ordered = options.ordered === true;\n    var defaultName = options.defaultName;\n    var removeDashes = options.removeDashes === true;\n    var matches;\n    var equalIndex = -1;\n    var result = ordered ? [] : {};\n    function handleError(message) {\n        if (options.errorHandler) {\n            options.errorHandler(message);\n            return;\n        } else {\n            throw createError(new Error(message));\n        }\n    }\n    function finishPart(endIndex) {\n        if (partStart === endIndex) {\n            //The part is an empty string... ignore it\n            return;\n        }\n        var name;\n        var value;\n        if (equalIndex != -1) {\n            name = strings.trim(attr.substring(partStart, equalIndex));\n            value = attr.substring(equalIndex + 1, endIndex);\n        } else {\n            if (defaultName) {\n                name = defaultName;\n                value = attr.substring(partStart, endIndex);\n                if (!strings.trim(value).length) {\n                    return;    //ignore empty parts\n                }\n            } else {\n                name = attr.substring(partStart, endIndex);\n            }\n        }\n        if (name) {\n            name = strings.trim(name);\n        }\n        if (!strings.trim(name).length && !strings.trim(value).length) {\n            equalIndex = -1;\n            return;    //ignore empty parts\n        }\n        if (types) {\n            var type = types[name] || types['*'];\n            if (type) {\n                if (value != null) {\n                    value = TypeConverter.convert(value, type.type, type.allowExpressions !== false);\n                }\n                if (type.name) {\n                    name = type.name;\n                }\n            } else {\n                handleError('Invalid sub-attribute name of \"' + name + '\"');\n            }\n        }\n        if (name && removeDashes) {\n            name = name.replace(/-([a-z])/g, function (match, lower) {\n                return lower.toUpperCase();\n            });\n        }\n        if (ordered) {\n            result.push({\n                name: name,\n                value: value\n            });\n        } else {\n            result[name] = value;\n        }\n        equalIndex = -1;    //Reset the equal index\n    }\n    /*\n     * Keep searching the string for the relevant tokens.\n     *\n     * NOTE: The regular expression will also return matches for JavaScript strings,\n     *       but they are just ignored. This ensures that semicolons inside strings\n     *       are not treated as\n     */\n    while ((matches = regExp.exec(attr))) {\n        //console.error(matches[0]);\n        if (matches[0] == ';') {\n            finishPart(matches.index);\n            partStart = matches.index + 1;\n            equalIndex = -1;\n        } else if (matches[0] == '=') {\n            if (equalIndex == -1) {\n                equalIndex = matches.index;\n            }\n        }\n    }\n    finishPart(attr.length);\n    //console.error(\"AttributeSplitter - result: \", result);\n    return result;\n};","/home/travis/build/npmtest/node-npmtest-raptor-templates/node_modules/raptor-templates/taglibs/core/TagHandlerNode.js":"/*\n * Copyright 2011 eBay Software Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n'use strict';\nvar extend = require('raptor-util').extend;\nvar forEachEntry = require('raptor-util').forEachEntry;\nvar stringify = require('raptor-json/stringify');\n\nfunction addHandlerVar(template, renderer) {\n    var handlerVars = template._handlerVars || (template._handlerVars = {});\n    var handlerVar = handlerVars[renderer];\n    if (!handlerVar) {\n        handlerVars[renderer] = handlerVar = renderer.replace(/[.\\-\\/]/g, '_').replace(/^[_]+/g, '');\n        template.addStaticVar(handlerVar, 'require(' + stringify(renderer) + ')');\n    }\n    return handlerVar;\n}\nfunction getPropsStr(props, template) {\n    var propsArray = [];\n    if (props) {\n        template.indent(function () {\n            forEachEntry(props, function (name, value) {\n                if (typeof value === 'function') {\n                    value = value();\n                }\n\n                if (template.isExpression(value)) {\n                    var expressionStr;\n                    template.indent(function () {\n                        expressionStr = value.expression.toString();\n                    });\n                    propsArray.push(template.indentStr() + stringify(name) + ': ' + expressionStr);\n                } else if (typeof value === 'string' || typeof value === 'object') {\n                    propsArray.push(template.indentStr() + stringify(name) + ': ' + stringify(value));\n                } else {\n                    propsArray.push(template.indentStr() + stringify(name) + ': ' + value);\n                }\n            });\n        });\n\n        \n        if (propsArray.length) {\n            return '{\\n' + propsArray.join(',\\n') + '\\n' + template.indentStr() + '}';\n        } else {\n            return '{}';\n        }\n    } else {\n        return '{}';\n    }\n}\nfunction TagHandlerNode(tag) {\n    if (!this.nodeType) {\n        TagHandlerNode.$super.call(this);\n    }\n    this.tag = tag;\n    this.dynamicAttributes = null;\n    this.inputExpression = null;\n    this.additionalVars = [];\n}\nTagHandlerNode.nodeType = 'element';\n\nTagHandlerNode.convertNode = function (node, tag) {\n    if (node._TagHandlerNode) {\n        return;\n    }\n\n    extend(node, TagHandlerNode.prototype);\n    TagHandlerNode.call(node, tag);\n};\n\nTagHandlerNode.prototype = {\n\n    _TagHandlerNode: true,\n\n    addNestedVariable: function(name) {\n        this.additionalVars.push(name);\n    },\n    addDynamicAttribute: function (name, value) {\n        if (!this.dynamicAttributes) {\n            this.dynamicAttributes = {};\n        }\n        this.dynamicAttributes[name] = value;\n    },\n    setDynamicAttributesProperty: function(name) {\n        this.dynamicAttributesProperty = name;\n    },\n    setInputExpression: function (expression) {\n        this.inputExpression = expression;\n    },\n    doGenerateCode: function (template) {\n        var rendererPath = template.getRequirePath(this.tag.renderer); // Resolve a path to the renderer relative to the directory of the template\n        var handlerVar = addHandlerVar(template, rendererPath);\n        var tagHelperVar = template.addStaticVar('_tag', '__helpers.t');\n\n        this.tag.forEachImportedVariable(function (importedVariable) {\n            this.setProperty(importedVariable.targetProperty, template.makeExpression(importedVariable.expression));\n        }, this);\n        \n        var _this = this;\n        var variableNames = [];\n        _this.tag.forEachVariable(function (nestedVar) {\n            var varName;\n            if (nestedVar.nameFromAttribute) {\n                var possibleNameAttributes = nestedVar.nameFromAttribute.split(/\\s+or\\s+|\\s*,\\s*/i);\n                for (var i = 0, len = possibleNameAttributes.length; i < len; i++) {\n                    var attrName = possibleNameAttributes[i];\n                    var keep = false;\n                    if (attrName.endsWith('|keep')) {\n                        keep = true;\n                        attrName = attrName.slice(0, 0 - '|keep'.length);\n                        possibleNameAttributes[i] = attrName;\n                    }\n                    varName = this.getAttribute(attrName);\n                    if (varName) {\n                        if (!keep) {\n                            this.removeProperty(attrName);\n                        }\n                        break;\n                    }\n                }\n                if (!varName) {\n                    this.addError('Attribute ' + possibleNameAttributes.join(' or ') + ' is required');\n                    varName = '_var';    // Let it continue with errors\n                }\n            } else {\n                varName = nestedVar.name;\n                if (!varName) {\n                    this.addError('Variable name is required');\n                    varName = '_var';    // Let it continue with errors\n                }\n            }\n            variableNames.push(varName);\n        }, this);\n\n        if (this.additionalVars.length) {\n            variableNames = variableNames.concat(this.additionalVars);\n        }\n\n        template.functionCall(tagHelperVar, function () {\n            template.code('context,\\n').indent(function () {\n                template.line(handlerVar + ',').indent();\n                if (_this.inputExpression) {\n                    template.code(_this.inputExpression);\n                } else {\n                    if (_this.dynamicAttributes) {\n                        template.indent(function() {\n                            _this.setProperty(_this.dynamicAttributesProperty, template.makeExpression(getPropsStr(_this.dynamicAttributes, template)));\n                        });\n                    }\n\n                    template.code(getPropsStr(_this.getProperties(), template));\n                }\n                if (_this.hasChildren()) {\n                    var bodyParams = [];\n                    variableNames.forEach(function (varName) {\n                        bodyParams.push(varName);\n                    });\n                    template.code(',\\n').line('function(' + bodyParams.join(',') + ') {').indent(function () {\n                        _this.generateCodeForChildren(template);\n                    }).indent().code('}');\n                }\n            });\n        });\n    }\n};\n\nmodule.exports = TagHandlerNode;","/home/travis/build/npmtest/node-npmtest-raptor-templates/node_modules/raptor-templates/bin/rhtmlc.js":"var raptorTemplatesCompiler = require('../compiler');\nvar fs = require('fs');\nvar nodePath = require('path');\nvar Minimatch = require('minimatch').Minimatch;\nvar cwd = process.cwd();\nrequire('raptor-polyfill/string/startsWith');\nrequire('raptor-polyfill/string/endsWith');\n\nvar mmOptions = {\n    matchBase: true,\n    dot: true,\n    flipNegate: true\n};\n\nfunction relPath(path) {\n    if (path.startsWith(cwd)) {\n        return path.substring(cwd.length+1);\n    }\n}\n\nvar args = require('raptor-args').createParser({\n        '--help': {\n            type: 'boolean',\n            description: 'Show this help message'\n        },\n        '--files --file -f *': {\n            type: 'string[]',\n            description: 'A set of directories or files to compile'\n        },\n        '--ignore -i': {\n            type: 'string[]',\n            description: 'An ignore rule (default: --ignore \"/node_modules\" \".*\")'\n        },\n        '--clean -c': {\n            type: 'boolean',\n            description: 'Clean all of the *.rhtml.js files'\n        }\n    })\n    .usage('Usage: $0 <pattern> [options]')\n    .example('Compile a single template', '$0 template.rhtml')\n    .example('Compile all templates in the current directory', '$0 .')\n    .example('Compile multiple templates', '$0 template.rhtml src/ foo/')\n    .example('Delete all *.rhtml.js files in the current directory', '$0 . --clean')\n    .validate(function(result) {\n        if (result.help) {\n            this.printUsage();\n            process.exit(0);\n        }\n\n        if (!result.files || result.files.length === 0) {\n            this.printUsage();\n            process.exit(1);\n        }\n    })\n    .onError(function(err) {\n        this.printUsage();\n\n        if (err) {\n            console.log();\n            console.log(err);\n        }\n\n        process.exit(1);\n    })\n    .parse();\n\n\nvar ignoreRules = args.ignore;\n\nif (!ignoreRules) {\n    ignoreRules = ['/node_modules', '.*'];\n}\n\nignoreRules = ignoreRules.filter(function (s) {\n    s = s.trim();\n    return s && !s.match(/^#/);\n});\n\nignoreRules = ignoreRules.map(function (pattern) {\n    \n    return new Minimatch(pattern, mmOptions);\n});\n\n\nfunction isIgnored(path, dir, stat) {\n    if (path.startsWith(dir)) {\n        path = path.substring(dir.length);\n    }\n\n    path = path.replace(/\\\\/g, '/');\n\n    var ignore = false;\n    var ignoreRulesLength = ignoreRules.length;\n    for (var i=0; i<ignoreRulesLength; i++) {\n        var rule = ignoreRules[i];\n        \n        var match = rule.match(path);\n        \n        if (!match && stat && stat.isDirectory()) {\n            try {\n                stat = fs.statSync(path);\n            } catch(e) {}\n\n            if (stat && stat.isDirectory()) {\n                match = rule.match(path + '/');\n            }    \n        }\n        \n\n        if (match) {\n            if (rule.negate) {\n                ignore = false;\n            } else {\n                ignore = true;\n            }\n        }\n    }\n\n    return ignore;\n}\n\nfunction walk(files, options, done) {\n    if (!files || files.length === 0) {\n        done('No files provided');\n    }\n\n    var pending = 0;\n\n    if (!Array.isArray(files)) {\n        files = [files];\n    }\n\n    var fileCallback = options.file;\n    var context = {\n        errors: [],\n        beginAsync: function() {\n            pending++;\n        },\n        endAsync: function(err) {\n            if (err) {\n                this.errors.push(err);\n            }\n\n            pending--;\n\n            if (pending === 0) {\n                if (this.errors.length) {\n                    done(this.errors);\n                } else {\n                    done(null);\n                }\n                \n            }\n        }\n    };\n\n    function doWalk(dir) {\n        context.beginAsync();\n        fs.readdir(dir, function(err, list) {\n            if (err) {\n                return context.endAsync(err);\n            }\n\n            if (list.length) {\n                list.forEach(function(basename) {\n                    var file = nodePath.join(dir, basename);\n\n                    context.beginAsync();\n                    fs.stat(file, function(err, stat) {\n                        if (err) {\n                            return context.endAsync(err);\n                        }\n\n                        if (!isIgnored(file, dir, stat)) {\n                            if (stat && stat.isDirectory()) {\n                                doWalk(file);\n                            } else {\n                                fileCallback(file, context);\n                            }    \n                        }\n\n                        context.endAsync();\n                    });\n                });\n            }\n\n            context.endAsync();\n        });\n    }\n\n    for (var i=0; i<files.length; i++) {\n        var file = nodePath.resolve(cwd, files[i]);\n\n        var stat = fs.statSync(file);\n\n        if (stat.isDirectory()) {\n            doWalk(file);\n        } else {\n            fileCallback(file, context);\n        }\n    }\n}\n\nif (args.clean) {\n    var deleteCount = 0;\n\n    walk(\n        args.files,\n        {\n            file: function(file, context) {\n                var basename = nodePath.basename(file);\n\n                if (basename.endsWith('.rhtml.js') || basename.endsWith('.rxml.js')) {\n                    context.beginAsync();\n                    fs.unlink(file, function(err) {\n                        if (err) {\n                            return context.endAsync(err);\n                        }\n                        deleteCount++;\n                        console.log('Deleted: ' + file);\n                        context.endAsync();\n                    });\n\n                    \n                }\n            }\n        },\n        function(err) {\n            if (deleteCount === 0) {\n                console.log('No *.rhtml.js files were found. Already clean.');\n            } else {\n                console.log('Deleted ' + deleteCount + ' file(s)');\n            }\n            \n        });\n\n} else {\n    var found = {};\n    var compileCount = 0;\n    var failed;\n    var failed = [];\n\n    var compile = function(path, context) {\n        if (found[path]) {\n            return;\n        }\n\n        found[path] = true;\n\n        var outPath = path + '.js';\n        console.log('Compiling:\\n  Input: ' + relPath(path) + '\\n  Output: ' + relPath(outPath) + '\\n');\n        context.beginAsync();\n        raptorTemplatesCompiler.compileFile(path, function(err, src) {\n            if (err) {\n                failed.push('Failed to compile \"' + path + '\". Error: ' + (err.stack || err));\n                context.endAsync(err);\n                return;\n            }\n\n            context.beginAsync();\n            fs.writeFile(outPath, src, {encoding: 'utf8'}, function(err, src) {\n                if (err) {\n                    failed.push('Failed to write \"' + path + '\". Error: ' + (err.stack || err));\n                    context.endAsync(err);\n                    return;\n                }\n\n                compileCount++;\n                context.endAsync();\n\n            });\n\n            context.endAsync();\n        });\n    };\n\n\n    if (args.files && args.files.length) {\n        walk(\n            args.files,\n            {\n                file: function(file, context) {\n                    var basename = nodePath.basename(file);\n\n                    if (basename.endsWith('.rhtml') || basename.endsWith('.rxml')) {\n                        compile(file, context);\n                    }\n                }\n            },\n            function(err) {\n                if (err) {\n                    if (failed.length) {\n                        console.error('The following errors occurred:\\n- ' + failed.join('\\n- '));\n                    } else {\n                        console.error(err);\n                    }\n\n                    return;\n                }\n\n                if (compileCount === 0) {\n                    console.log('No templates found');\n                } else {\n                    console.log('Compiled ' + compileCount + ' templates(s)');\n                }\n                \n            });\n    }    \n}","/home/travis/build/npmtest/node-npmtest-raptor-templates/node_modules/raptor-templates/compiler/expressions.js":"var ExpressionParser = require('./ExpressionParser');\n\nfunction registerCustomExpressionHandler(name, func) {\n    ExpressionParser.custom[name] = func;\n}\n\nexports.registerCustomExpressionHandler = registerCustomExpressionHandler;","/home/travis/build/npmtest/node-npmtest-raptor-templates/node_modules/raptor-templates/runtime/loader_browser.js":"module.exports = function load(templatePath) {\n    // We make the assumption that the template path is a \n    // fully resolved module path and that the module exists\n    // as a CommonJS module\n    return require(templatePath);\n};","/home/travis/build/npmtest/node-npmtest-raptor-templates/node_modules/raptor-templates/taglibs/caching/cached-fragment-tag.js":"'use strict';\nvar raptorCache;\nvar defaultCacheManager;\nvar req = require; // Fool the raptor-optimizer\n\n\nmodule.exports = {\n    render: function (input, context) {\n        if (raptorCache === undefined) {\n            try {\n                raptorCache = req('raptor-cache');\n            }\n            catch(e) {\n                throw new Error('The \"raptor-cache\" module should be installed as an application-level dependency when using caching tags');\n            }\n\n            defaultCacheManager = raptorCache.createCacheManager({\n                profiles: {\n                    '*': {\n                        'raptor-templates/cached-fragment': {\n                            store: 'memory',\n                            encoding: 'utf8'\n                        }\n                    }\n                }\n            });\n        }\n        \n        var cacheKey = input.cacheKey;\n        if (!cacheKey) {\n            throw new Error('cache-key is required for <cached-fragment>');\n        }\n\n        var cacheManager = input.cacheManager || defaultCacheManager;\n\n        var cache = cacheManager.getCache(input.cacheName || 'raptor-templates/cached-fragment');\n        \n        var asyncContext = context.beginAsync();\n        \n        cache.get(cacheKey,\n            {\n                builder: function(callback) {\n                    var result = context.captureString(function () {\n                        if (input.invokeBody) {\n                            input.invokeBody();\n                        }\n                    });\n                    callback(null, result);\n                }\n            }, function(err, result) {\n                if (err) {\n                    return asyncContext.error(err);\n                }\n                \n                asyncContext.end(result);\n            });\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-raptor-templates/node_modules/raptor-templates/taglibs/core/AssignNode.js":"/*\n * Copyright 2011 eBay Software Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n'use strict';\nvar varNameRegExp = /^[A-Za-z_][A-Za-z0-9_]*$/;\nfunction AssignNode(props) {\n    AssignNode.$super.call(this);\n    if (props) {\n        this.setProperties(props);\n    }\n}\nAssignNode.prototype = {\n    doGenerateCode: function (template) {\n        var varName = this.getProperty('var');\n        var value = this.getProperty('value');\n        if (!varName) {\n            this.addError('\"var\" attribute is required');\n        } else if (!varNameRegExp.test(varName)) {\n            this.addError('Invalid variable name of \"' + varName + '\"');\n            varName = null;\n        }\n        if (!value) {\n            this.addError('\"value\" attribute is required');\n        }\n        if (varName) {\n            template.statement(varName + '=' + value + ';');\n        }\n    }\n};\n\nmodule.exports = AssignNode;","/home/travis/build/npmtest/node-npmtest-raptor-templates/node_modules/raptor-templates/taglibs/core/ChooseNode.js":"/*\n * Copyright 2011 eBay Software Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n'use strict';\n\nvar WhenNode = require('./WhenNode');\nvar OtherwiseNode = require('./OtherwiseNode');\nfunction ChooseNode(props) {\n    ChooseNode.$super.call(this);\n}\nChooseNode.prototype = {\n    doGenerateCode: function (template) {\n        var otherwiseNode = null;\n        var foundWhenNode = false;\n        var allowedNodes = [];\n        this.forEachChild(function (child) {\n            if (child.isTextNode()) {\n                var trimmed = child.getText().trim();\n                if (trimmed !== '') {\n                    this.addError('Static text \"' + trimmed + '\" is not allowed in ' + this.toString() + ' tag.');\n                }\n            } else if (child.getNodeClass() === WhenNode) {\n                if (otherwiseNode) {\n                    this.addError(otherwiseNode + ' tag must be last child of tag ' + this + '.');\n                    return;\n                }\n                if (!foundWhenNode) {\n                    foundWhenNode = true;\n                    child.firstWhen = true;\n                }\n                allowedNodes.push(child);\n            } else if (child.getNodeClass() === OtherwiseNode) {\n                if (otherwiseNode) {\n                    this.addError('More than one ' + otherwiseNode + ' tag is not allowed as child of tag ' + this + '.');\n                    return;\n                }\n                otherwiseNode = child;\n                allowedNodes.push(otherwiseNode);\n            } else {\n                this.addError(child + ' tag is not allowed as child of tag ' + this + '.');\n                child.generateCode(template);    //Generate the code for the children so that we can still show errors to the user for nested nodes\n            }\n        }, this);\n        allowedNodes.forEach(function (child, i) {\n            child.hasElse = i < allowedNodes.length - 1;\n            child.generateCode(template);\n        });\n        if (!foundWhenNode) {\n            this.addError('' + otherwiseNode + ' tag is required to have at least one sibling <c-when> tag.');\n        }\n    }\n};\n\nmodule.exports = ChooseNode;","/home/travis/build/npmtest/node-npmtest-raptor-templates/node_modules/raptor-templates/taglibs/core/WhenNode.js":"/*\n * Copyright 2011 eBay Software Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n'use strict';\nfunction WhenNode(props) {\n    WhenNode.$super.call(this);\n    if (props) {\n        this.setProperties(props);\n    }\n}\nWhenNode.prototype = {\n    doGenerateCode: function (template) {\n        var test = this.getProperty('test');\n        if (!test) {\n            this.addError('\"test\" attribute is required for ' + this.toString() + ' tag.');\n        }\n        var ifCode = 'if (' + test + ')';\n        if (!this.firstWhen) {\n            template.line('else ' + ifCode + ' {');\n        } else {\n            template.statement(ifCode + ' {');\n        }\n        template.indent(function () {\n            this.generateCodeForChildren(template);\n        }, this).line('}');\n    }\n};\n\nmodule.exports = WhenNode;","/home/travis/build/npmtest/node-npmtest-raptor-templates/node_modules/raptor-templates/taglibs/core/OtherwiseNode.js":"/*\n * Copyright 2011 eBay Software Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n'use strict';\nfunction OtherwiseNode(props) {\n    OtherwiseNode.$super.call(this);\n    if (props) {\n        this.setProperties(props);\n    }\n}\nOtherwiseNode.prototype = {\n    doGenerateCode: function (template) {\n        template.line('else {').indent(function () {\n            this.generateCodeForChildren(template);\n        }, this).line('}');\n    },\n    toString: function () {\n        return '<c-otherwise>';\n    }\n};\n\nmodule.exports = OtherwiseNode;","/home/travis/build/npmtest/node-npmtest-raptor-templates/node_modules/raptor-templates/taglibs/core/core-tag-transformer.js":"/*\n * Copyright 2011 eBay Software Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n'use strict';\nfunction removeDashes(str) {\n    return str.replace(/-([a-z])/g, function (match, lower) {\n        return lower.toUpperCase();\n    });\n}\nvar extend = require('raptor-util').extend;\n\nvar WriteNode = require('./WriteNode');\nvar ForNode = require('./ForNode');\nvar IfNode = require('./IfNode');\nvar ElseIfNode = require('./ElseIfNode');\nvar ElseNode = require('./ElseNode');\nvar WithNode = require('./WithNode');\nvar WhenNode = require('./WhenNode');\nvar OtherwiseNode = require('./OtherwiseNode');\nvar TagHandlerNode = require('./TagHandlerNode');\nvar IncludeNode = require('./IncludeNode');\n\nvar resolver = require('raptor-modules/resolver');\n\nvar coreAttrHandlers = [\n    [\n        'c-space', function(attr, node) {\n            this['c-whitespace'](attr, node);\n        }\n    ],\n    [\n        'c-whitespace', function(attr, node) {\n            if (attr === 'preserve') {\n                node.setPreserveWhitespace(true);\n            }\n        }\n    ],\n    [\n        'c-escape-xml', function(attr, node) {\n            node.setEscapeXmlBodyText(attr !== 'false');\n        }\n    ],\n    [\n        'c-parse-body-text', function(attr, node) {\n            node.parseBodyText = attr !== 'false';\n        }\n    ],\n    [\n        'c-when', function(attr, node) {\n            var whenNode = this.compiler.createNode(WhenNode, {\n                    test: this.template.makeExpression(attr),\n                    pos: node.getPosition()\n                });\n            node.parentNode.replaceChild(whenNode, node);\n            whenNode.appendChild(node);\n        }\n    ],\n    [\n        'c-otherwise', function(attr, node) {\n            var otherwiseNode = this.compiler.createNode(OtherwiseNode, { pos: node.getPosition() });\n            node.parentNode.replaceChild(otherwiseNode, node);\n            otherwiseNode.appendChild(node);\n        }\n    ],\n    [\n        'c-attrs', function(attr, node) {\n            if (!node.addDynamicAttributes) {\n                node.addError('Node does not support the \"c-attrs\" attribute');\n            } else {\n                node.addDynamicAttributes(attr);\n            }\n        }\n    ],\n    [\n        'c-for-each', function(attr, node) {\n            this['for'](attr, node);\n        }\n    ],\n    [\n        'c-for', function(attr, node) {\n            var forEachProps = this.compiler.parseAttribute(attr, {\n                    each: { type: 'custom' },\n                    separator: { type: 'expression' },\n                    'iterator': { type: 'expression' },\n                    'status-var': { type: 'identifier' },\n                    'for-loop': {\n                        type: 'boolean',\n                        allowExpressions: false\n                    }\n                }, {\n                    removeDashes: true,\n                    defaultName: 'each',\n                    errorHandler: function (message) {\n                        node.addError('Invalid c-for attribute of \"' + attr + '\". Error: ' + message);\n                    }\n                });\n            forEachProps.pos = node.getPosition();\n            //Copy the position property\n            var forEachNode = this.compiler.createNode(ForNode, forEachProps);\n            //Surround the existing node with an \"forEach\" node by replacing the current\n            //node with the new \"forEach\" node and then adding the current node as a child\n            node.parentNode.replaceChild(forEachNode, node);\n            forEachNode.appendChild(node);\n        }\n    ],\n    [\n        'c-if', function(attr, node) {\n            var ifNode = this.compiler.createNode(IfNode, {\n                    test: this.template.makeExpression(attr),\n                    pos: node.getPosition()\n                });\n            //Surround the existing node with an \"if\" node by replacing the current\n            //node with the new \"if\" node and then adding the current node as a child\n            node.parentNode.replaceChild(ifNode, node);\n            ifNode.appendChild(node);\n        }\n    ],\n    [\n        'c-else-if', function(attr, node) {\n            var elseIfNode = this.compiler.createNode(ElseIfNode, {\n                    test: this.template.makeExpression(attr),\n                    pos: node.getPosition()\n                });\n            //Surround the existing node with an \"if\" node by replacing the current\n            //node with the new \"if\" node and then adding the current node as a child\n            node.parentNode.replaceChild(elseIfNode, node);\n            elseIfNode.appendChild(node);\n        }\n    ],\n    [\n        'c-else', function(attr, node) {\n            var elseNode = this.compiler.createNode(ElseNode, { pos: node.getPosition() });\n            //Surround the existing node with an \"if\" node by replacing the current\n            //node with the new \"if\" node and then adding the current node as a child\n            node.parentNode.replaceChild(elseNode, node);\n            elseNode.appendChild(node);\n        }\n    ],\n    [\n        'c-with', function(attr, node) {\n            var withNode = this.compiler.createNode(WithNode, {\n                    vars: attr,\n                    pos: node.getPosition()\n                });\n            node.parentNode.replaceChild(withNode, node);\n            withNode.appendChild(node);\n        }\n    ],\n    [\n        'c-body-content', function(attr, node) {\n            this.content(attr);\n        }\n    ],\n    [\n        'c-content', function(attr, node) {\n            var newChild = this.compiler.createNode(WriteNode, {\n                    expression: attr,\n                    pos: node.getPosition()\n                });\n            node.removeChildren();\n            node.appendChild(newChild);\n        }\n    ],\n    [\n        'c-trim-body-indent', function(attr, node) {\n            if (attr === 'true') {\n                node.trimBodyIndent = true;\n            }\n        }\n    ],\n    [\n        'c-strip', function(attr, node) {\n            if (!node.setStripExpression) {\n                node.addError('The c-strip directive is not allowed for target node');\n            }\n            node.setStripExpression(attr);\n        }\n    ],\n    [\n        'c-replace', function(attr, node) {\n            var replaceWriteNode = this.compiler.createNode(WriteNode, {\n                    expression: attr,\n                    pos: node.getPosition()\n                });\n            //Replace the existing node with an node that only has children\n            node.parentNode.replaceChild(replaceWriteNode, node);\n            return replaceWriteNode;\n        }\n    ],\n    [\n        'c-input', function(attr, node) {\n            this.inputAttr = attr;\n        }\n    ],\n    [\n        'c-data', function(attr, node) {\n            this.inputAttr = attr;\n        }\n    ]\n];\n\n\nfunction Transformer(template, compiler) {\n    this.template = template;\n    this.compiler = compiler;\n    this.inputAttr = null;\n}\n\nTransformer.prototype = {\n    transformNode: function(node) {\n\n        for (var i=0, len=coreAttrHandlers.length; i<len; i++) {\n            var attrHandler = coreAttrHandlers[i];\n            var name = attrHandler[0];\n            var attr = node.getAttribute(name);\n            if (attr != null) {\n                node.removeAttribute(name);\n                node = this[name](attr, node) || node;\n            }\n        }\n\n        return node;\n    }\n};\n\ncoreAttrHandlers.forEach(function(attrHandler) {\n    var name = attrHandler[0];\n    var func = attrHandler[1];\n    Transformer.prototype[name] = func;\n});\n\n\nfunction handleAttr(node, compiler, template) {\n    var parentNode = node.parentNode;\n    if (!parentNode.isElementNode()) {\n        node.addError(node.toString() + ' tag is not nested within an element tag.');\n        return;\n    }\n    var hasValue = node.hasAttribute('value');\n    var attrName = node.getAttribute('name');\n    var attrValue = node.getAttribute('value');\n    var attrUri = node.getAttribute('namespace') || '';\n    var attrPrefix = node.getAttribute('prefix') || '';\n    if (parentNode.hasAttributeNS(attrUri, attrName)) {\n        node.addError(node.toString() + ' tag adds duplicate attribute with name \"' + attrName + '\"' + (attrUri ? ' and URI \"' + attrUri + '\"' : ''));\n        return;\n    }\n    node.removeAttribute('name');\n    node.removeAttribute('value');\n    node.removeAttribute('namespace');\n    node.removeAttribute('prefix');\n    if (node.hasAttributesAnyNS()) {\n        var invalidAttrs = node.getAllAttributes().map(function (attr) {\n                return attr.qName;\n            });\n        node.addError('Invalid attributes for tag ' + node.toString() + ': ' + invalidAttrs.join(', '));\n        return;\n    }\n    //Cleanup whitespace between <c-attr> tags\n    if (node.previousSibling && node.previousSibling.isTextNode() && node.previousSibling.getText().trim() === '') {\n        node.previousSibling.detach();\n    }\n    if (node.nextSibling && node.nextSibling.isTextNode() && node.nextSibling.getText().trim() === '') {\n        node.nextSibling.detach();\n    }\n    if (node.nextSibling && node.nextSibling.isTextNode()) {\n        node.nextSibling.setText(node.nextSibling.getText().replace(/^\\n\\s*/, ''));\n    }\n    node.detach();\n    //Remove the node out of the tree\n    compiler.transformTree(node, template);\n    if (hasValue) {\n        parentNode.setAttributeNS(attrUri, attrName, attrValue, attrPrefix);\n    } else {\n        node.setEscapeXmlContext('ATTRIBUTE');\n        //Escape body text and expressions as attributes\n        parentNode.setAttributeNS(attrUri, attrName, node.getBodyContentExpression(template), attrPrefix, false);\n    }\n}\n\nfunction findNestedAttrs(node, compiler, template) {\n    node.forEachChild(function (child) {\n        if (child.qName === 'c-attr') {\n            handleAttr(child, compiler, template);\n        }\n    });\n}\n\n\n\nmodule.exports = function transform(node, compiler, template) {\n\n    //Find and handle nested <c-attrs> elements\n    findNestedAttrs(node, compiler, template);\n\n    var tag;\n\n\n    function convertAttrValue(attr, type, attrDef) {\n        type = type || (attrDef ? attrDef.type : 'string') || 'string';\n\n        try {\n            return compiler.convertType(attr.value, type, attrDef ? attrDef.allowExpressions !== false : true);\n        } catch (e) {\n            node.addError('Invalid attribute value of \"' + attr.value + '\" for attribute \"' + attr.name + '\": ' + e.message);\n            return attr.value;\n        }\n    }\n\n    function forEachProp(callback, thisObj) {\n        var foundProps = {};\n\n        node.forEachAttributeAnyNS(function (attr) {\n            var attrDef = compiler.taglibs.getAttribute(node, attr);\n            if (!attrDef) {\n                // var isAttrForTaglib = compiler.taglibs.isTaglib(attrUri);\n                //Tag doesn't allow dynamic attributes\n                node.addError('The tag \"' + tag.name + '\" in taglib \"' + tag.taglibId + '\" does not support attribute \"' + attr + '\"');\n                return;\n            }\n\n            var type = attrDef.type || 'string';\n\n            var value;\n\n            if (compiler.isExpression(attr.value)) {\n                value = attr.value;\n            } else {\n                if (type === 'path') {\n                    var pathVar;\n                    if (compiler.hasExpression(attr.value)) {\n                        value = convertAttrValue(attr, 'string', attrDef);\n                    } else {\n                        // Resolve the static string to a full path only once\n                        pathVar = template.addStaticVar(attr.value, 'require.resolve(' + compiler.convertType(attr.value, 'string', true) + ')');\n                        value = compiler.makeExpression(pathVar);\n                    }\n                } else if (type === 'template') {\n                    var templateVar;\n                    if (compiler.hasExpression(attr.value)) {\n                        value = compiler.makeExpression('__helpers.l(' + convertAttrValue(attr, 'string', attrDef) + ')');\n                    } else {\n                        // Resolve the static string to a full path only once\n                        templateVar = template.addStaticVar(attr.value, '__helpers.l(require.resolve(' + compiler.convertType(attr.value, 'string', true) + '))');\n                        value = compiler.makeExpression(templateVar);\n                    }\n                } else {\n                    value = convertAttrValue(attr, type, attrDef);\n                }\n            }\n            var propName;\n            if (attrDef.dynamicAttribute) {\n                propName = attr.qName;\n            } else {\n                if (attrDef.targetProperty) {\n                    propName = attrDef.targetProperty;\n                } else if (attrDef.preserveName) {\n                    propName = attr.localName;\n                } else {\n                    propName = removeDashes(attr.localName);\n                }\n            }\n\n            foundProps[propName] = true;\n            callback.call(thisObj, propName, value, attrDef);\n        });\n\n        tag.forEachAttribute(function (attr) {\n            if (attr.hasOwnProperty('defaultValue') && !foundProps[attr.name]) {\n                callback.call(thisObj, attr.name, template.makeExpression(JSON.stringify(attr.defaultValue)), '', attr);\n            }\n        });\n    }\n\n    tag = node.tag || compiler.taglibs.getTag(node);\n\n    var transformer = new Transformer(template, compiler);\n    node = transformer.transformNode(node);\n    var inputAttr = transformer.inputAttr;\n\n    if (tag) {\n        if (tag.preserveWhitespace) {\n            node.setPreserveWhitespace(true);\n        }\n        if (tag.renderer || tag.template) {\n            if (tag.renderer) {\n                //Instead of compiling as a static XML element, we'll\n                //make the node render as a tag handler node so that\n                //writes code that invokes the handler\n                TagHandlerNode.convertNode(node, tag);\n                if (inputAttr) {\n                    node.setInputExpression(template.makeExpression(inputAttr));\n                }\n            } else {\n                var templatePath = resolver.deresolve(tag.template, compiler.dirname);\n                // The tag is mapped to a template that will be used to perform\n                // the rendering so convert the node into a \"IncludeNode\" that can\n                // be used to include the output of rendering a template\n                IncludeNode.convertNode(node, templatePath);\n            }\n\n            forEachProp(function (name, value, attrDef) {\n                if (attrDef.dynamicAttribute && attrDef.targetProperty) {\n                    if (attrDef.removeDashes === true) {\n                        name = removeDashes(name);\n                    }\n                    if (node.addDynamicAttribute) {\n                        node.addDynamicAttribute(name, value);\n                        node.setDynamicAttributesProperty(attrDef.targetProperty);    \n                    } else {\n                        node.setProperty(name, value);    \n                    }\n                } else {\n                    node.setProperty(name, value);\n                }\n            });\n\n        } else if (tag.nodeClass) {\n            var NodeCompilerClass = require(tag.nodeClass);\n            compiler.inheritNode(NodeCompilerClass);\n            extend(node, NodeCompilerClass.prototype);\n            NodeCompilerClass.call(node);\n            node.setNodeClass(NodeCompilerClass);\n            forEachProp(function (name, value) {\n                node.setProperty(name, value);\n            });\n        }\n    }\n};","/home/travis/build/npmtest/node-npmtest-raptor-templates/node_modules/raptor-templates/taglibs/core/WriteNode.js":"/*\n * Copyright 2011 eBay Software Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n'use strict';\n\nfunction WriteNode(props) {\n    WriteNode.$super.call(this, 'c-write');\n    if (props) {\n        this.setProperties(props);\n    }\n}\n\nWriteNode.nodeType = 'element';\n\nWriteNode.prototype = {\n    doGenerateCode: function (template) {\n        var expression = this.getExpression();\n        var escapeXml;\n        var options = {};\n\n        if (this.hasProperty('escapeXml')) {\n            escapeXml = this.getProperty('escapeXml') !== false;\n        } else {\n            escapeXml = this.getProperty('escape-xml') !== false;\n        }\n\n        if (escapeXml === true) {\n            if (this.getEscapeXmlContext() === 'ATTRIBUTE') {\n                options.escapeXmlAttr = true;\n            } else {\n                options.escapeXml = true;\n            }\n        }\n        if (expression) {\n            template.write(expression, options);\n        }\n    },\n    getExpression: function () {\n        return this.getProperty('expression') || this.getProperty('value') || this.getAttribute('expression') || this.getAttribute('value');\n    },\n    toString: function () {\n        return '<c-write expression=\"' + this.getExpression() + '\">';\n    }\n};\n\nmodule.exports = WriteNode;","/home/travis/build/npmtest/node-npmtest-raptor-templates/node_modules/raptor-templates/taglibs/core/ForNode.js":"/*\n * Copyright 2011 eBay Software Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n'use strict';\nvar forEachRegEx = /^\\s*([A-Za-z_][A-Za-z0-9_]*)\\s+in\\s+(.+)$/;\nvar forEachPropRegEx = /^\\(\\s*([A-Za-z_][A-Za-z0-9_]*)\\s*,\\s*([A-Za-z_][A-Za-z0-9_]*)\\s*\\)\\s+in\\s+(.+)$/;\nvar forRangeRegEx = /^\\s*([A-Za-z_][A-Za-z0-9_]*)\\s+from\\s+(.+)$/; // i from 0 to 10  or  i from 0 to 10 step 5\nvar forRangeKeywordsRegExp = /\"(?:[^\"]|\\\\\")*\"|'(?:[^']|\\\\')*'|\\s+(to|step)\\s+/g;\nvar integerRegExp = /^-?\\d+$/;\nvar numberRegExp = /^-?(?:\\d+|\\d+\\.\\d*|\\d*\\.\\d+|\\d+\\.\\d+)$/;\n\nfunction convertNumber(str) {\n    if (!str) {\n        return str;\n    }\n\n    if (integerRegExp.test(str)) {\n        return parseInt(str, 10);\n    } else if (numberRegExp.test(str)) {\n        return parseFloat(str);\n    } else {\n        return str;\n    }\n}\n\nvar stringify = require('raptor-json/stringify').stringify;\nfunction parseForEach(value) {\n    var match = value.match(forEachRegEx);\n    if (match) {\n        return {\n            'var': match[1],\n            'in': match[2]\n        };\n    } else if ((match = value.match(forEachPropRegEx))) {\n        \n\n        return {\n            'nameVar': match[1],\n            'valueVar': match[2],\n            'in': match[3]\n        };\n    } else if ((match = value.match(forRangeRegEx))) {\n        var nameVar = match[1];\n\n\n        var remainder = match[2];\n        var rangeMatches;\n\n        var fromStart = 0;\n        var fromEnd = -1;\n\n        var toStart = -1;\n        var toEnd = remainder.length;\n\n        var stepStart = -1;\n        var stepEnd = -1;\n\n        while ((rangeMatches = forRangeKeywordsRegExp.exec(remainder))) {\n            if (rangeMatches[1] === 'to') {\n                fromEnd = rangeMatches.index;\n                toStart = forRangeKeywordsRegExp.lastIndex;\n            } else if (rangeMatches[1] === 'step') {\n                if (toStart === -1) {\n                    continue;\n                }\n                toEnd = rangeMatches.index;\n                stepStart = forRangeKeywordsRegExp.lastIndex;\n                stepEnd = remainder.length;\n            }\n        }\n\n        if (toStart === -1 || fromEnd === -1) {\n            throw new Error('Invalid each attribute of \"' + value + '\"');\n        }\n\n        var from = remainder.substring(fromStart, fromEnd).trim();\n        var to = remainder.substring(toStart, toEnd).trim();\n        var step;\n\n        from = convertNumber(from);\n        to = convertNumber(to);\n\n        if (stepStart !== -1) {\n            step = remainder.substring(stepStart, stepEnd).trim();\n            step = convertNumber(step);\n        } else {\n            if (typeof from === 'number' && typeof to === 'number') {\n                if (from < to) {\n                    step = 1;\n                } else {\n                    step = -1;\n                }\n            } else {\n                step = 1;    \n            }\n            \n        }\n\n        return {\n            'nameVar': nameVar,\n            'from': from,\n            'to': to,\n            'step': step\n        };\n    } else {\n        throw new Error('Invalid each attribute of \"' + value + '\"');\n    }\n}\nfunction ForNode(props) {\n    ForNode.$super.call(this);\n    if (props) {\n        this.setProperties(props);\n    }\n}\nForNode.prototype = {\n    doGenerateCode: function (template) {\n        var each = this.getProperty('each');\n        var separator = this.getProperty('separator');\n        var statusVar = this.getProperty('statusVar') || this.getProperty('varStatus');\n        var customIterator = this.getProperty('iterator');\n        if (!each) {\n            this.addError('\"each\" attribute is required');\n            this.generateCodeForChildren(template);\n            return;\n        }\n        var parts;\n        try {\n            parts = parseForEach(each);\n        } catch (e) {\n            this.addError(e.message);\n            this.generateCodeForChildren(template);\n            return;\n        }\n\n        if (parts.hasOwnProperty('from')) {\n            // This is a range loop\n            \n            \n            var nameVar = parts.nameVar;\n            var from = parts.from;\n            var to = parts.to;\n            var step = parts.step;\n            var comparison = '<=';\n\n            if (typeof step === 'number') {\n                if (step < 0) {\n                    comparison = '>=';\n                }\n\n                if (step === 1) {\n                    step = nameVar + '++';\n                } else if (step  === -1) {\n                    step = nameVar + '--';\n                } else if (step > 0) {\n                    step = nameVar + '+=' + step;\n                } else if (step === 0) {\n                    throw new Error('Invalid step of 0');\n                } else if (step < 0) {\n                    step = 0-step; // Make the step positive and switch to -=\n                    step = nameVar + '-=' + step;\n                }\n            } else {\n                step = nameVar + '+=' + step;\n            }\n\n            template.statement('(function() {').indent(function () {\n                template.statement('for (var ' + nameVar + '=' + from + '; ' + nameVar + comparison + to + '; ' + step + ') {').indent(function () {\n                    this.generateCodeForChildren(template);\n                }, this).line('}');\n            }, this).line('}());');\n            return;\n        }\n\n        var items = template.makeExpression(parts['in']);\n        var varName = parts['var'];\n        var nameVarName = parts.nameVar;\n        var valueVarName = parts.valueVar;\n        if (nameVarName) {\n            if (separator) {\n                this.addError('Separator is not supported when looping over properties');\n                this.generateCodeForChildren(template);\n                return;\n            }\n            if (statusVar) {\n                this.addError('Loop status variable not supported when looping over properties');\n                this.generateCodeForChildren(template);\n                return;\n            }\n        }\n        if (separator && !statusVar) {\n            statusVar = '__loop';\n        }\n        var funcName;\n        var forEachParams;\n\n        if (customIterator) {\n            var statusVarFlag = '';\n            if (statusVar) {\n                statusVarFlag = ', true';\n                forEachParams = [\n                    varName,\n                    statusVar\n                ];\n            } else {\n                forEachParams = [varName];\n            }\n            template.statement(customIterator + '(' + items + ', function(' + forEachParams.join(',') + ') {').indent(function () {\n                this.generateCodeForChildren(template);\n            }, this).line('}' + statusVarFlag + ');');\n        } else if (statusVar) {\n            forEachParams = [\n                varName,\n                statusVar\n            ];\n            funcName = template.getStaticHelperFunction('forEachWithStatusVar', 'fv');\n            template.statement(funcName + '(' + items + ', function(' + forEachParams.join(',') + ') {').indent(function () {\n                this.generateCodeForChildren(template);\n                if (separator) {\n                    template.statement('if (!' + statusVar + '.isLast()) {').indent(function () {\n                        template.write(template.isExpression(separator) ? separator.getExpression() : stringify(separator));\n                    }, this).line('}');\n                }\n            }, this).line('});');\n        } else {\n            if (this.getProperty('forLoop') === true) {\n                forEachParams = [\n                    '__array',\n                    '__index',\n                    '__length',\n                    varName\n                ];\n                template.statement(template.getStaticHelperFunction('forLoop', 'fl') + '(' + items + ', function(' + forEachParams.join(',') + ') {').indent(function () {\n                    template.statement('for (;__index<__length;__index++) {').indent(function () {\n                        template.statement(varName + '=__array[__index];');\n                        this.generateCodeForChildren(template);\n                    }, this).line('}');\n                }, this).line('});');\n            } else {\n                forEachParams = nameVarName ? [\n                    nameVarName,\n                    valueVarName\n                ] : [varName];\n                funcName = nameVarName ? template.getStaticHelperFunction('forEachProp', 'fp') : template.getStaticHelperFunction('forEach', 'f');\n                template.statement(funcName + '(' + items + ', function(' + forEachParams.join(',') + ') {').indent(function () {\n                    this.generateCodeForChildren(template);\n                }, this).line('});');\n            }\n        }\n    }\n};\n\nmodule.exports = ForNode;","/home/travis/build/npmtest/node-npmtest-raptor-templates/node_modules/raptor-templates/taglibs/core/IfNode.js":"/*\n * Copyright 2011 eBay Software Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n'use strict';\nfunction IfNode(props) {\n    IfNode.$super.call(this, 'c-if');\n    if (props) {\n        this.setProperties(props);\n    }\n}\n\nIfNode.nodeType = 'element';\n\nIfNode.prototype = {\n    doGenerateCode: function (template) {\n        var test = this.getProperty('test');\n        if (!test) {\n            this.addError('\"test\" attribute is required');\n        }\n        template.statement('if (' + test + ') {').indent(function () {\n            this.generateCodeForChildren(template);\n        }, this).line('}');\n    }\n};\n\nmodule.exports = IfNode;","/home/travis/build/npmtest/node-npmtest-raptor-templates/node_modules/raptor-templates/taglibs/core/ElseIfNode.js":"/*\n * Copyright 2011 eBay Software Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n'use strict';\nfunction ElseIfNode(props) {\n    ElseIfNode.$super.call(this, 'c-else-if');\n    if (props) {\n        this.setProperties(props);\n    }\n}\nElseIfNode.nodeType = 'element';\n\nElseIfNode.prototype = {\n    doGenerateCode: function (template) {\n        var test = this.getProperty('test');\n        if (!test) {\n            this.addError('\"test\" attribute is required');\n            return;\n        }\n        template.line('else if (' + test + ') {').indent(function () {\n            this.generateCodeForChildren(template);\n        }, this).line('}');\n    }\n};\n\nmodule.exports = ElseIfNode;","/home/travis/build/npmtest/node-npmtest-raptor-templates/node_modules/raptor-templates/taglibs/core/ElseNode.js":"/*\n * Copyright 2011 eBay Software Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n'use strict';\nfunction ElseNode(props) {\n    ElseNode.$super.call(this, 'c-else');\n    if (props) {\n        this.setProperties(props);\n    }\n}\n\nElseNode.nodeType = 'element';\n\nElseNode.prototype = {\n    doGenerateCode: function (template) {\n        if (this.valid == null) {\n            return;    //Don't generate code for an invalid else\n        }\n        template.line('else {').indent(function () {\n            this.generateCodeForChildren(template);\n        }, this).line('}');\n    }\n};\n\nmodule.exports = ElseNode;","/home/travis/build/npmtest/node-npmtest-raptor-templates/node_modules/raptor-templates/taglibs/core/WithNode.js":"/*\n * Copyright 2011 eBay Software Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n'use strict';\nvar varNameRegExp = /^[A-Za-z_][A-Za-z0-9_]*$/;\nfunction WithNode(props) {\n    WithNode.$super.call(this);\n    if (props) {\n        this.setProperties(props);\n    }\n}\nWithNode.prototype = {\n    doGenerateCode: function (template) {\n        var vars = this.getProperty('vars');\n        var _this = this;\n        if (!vars) {\n            this.addError('\"vars\" attribute is required');\n        }\n        var withVars = template.parseAttribute(vars, { '*': { type: 'expression' } }, {\n                ordered: true,\n                errorHandler: function (message) {\n                    _this.addError('Invalid variable declarations of \"' + vars + '\". Error: ' + message);\n                }\n            });\n        var varDefs = [];\n        withVars.forEach(function (withVar, i) {\n            if (!varNameRegExp.test(withVar.name)) {\n                this.addError('Invalid variable name of \"' + withVar.name + '\" in \"' + vars + '\"');\n            }\n            varDefs.push((i > 0 ? template.indentStr(1) + '    ' : '') + withVar.name + (withVar.value ? '=' + withVar.value : '') + (i < withVars.length - 1 ? ',\\n' : ';'));\n        }, this);\n        template.statement('(function() {').indent(function () {\n            template.statement('var ' + varDefs.join(''));\n            this.generateCodeForChildren(template);\n        }, this).line('}());');\n    }\n};\n\nmodule.exports = WithNode;","/home/travis/build/npmtest/node-npmtest-raptor-templates/node_modules/raptor-templates/taglibs/core/IncludeNode.js":"/*\n * Copyright 2011 eBay Software Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n'use strict';\nvar stringify = require('raptor-json/stringify');\nvar nodePath = require('path');\nvar fs = require('fs');\n\nvar extend = require('raptor-util').extend;\nfunction IncludeNode(props) {\n    if (IncludeNode.$super) {\n        IncludeNode.$super.call(this);    \n    }\n    \n    if (props) {\n        this.setProperties(props);\n    }\n}\nIncludeNode.convertNode = function (node, template) {\n    extend(node, IncludeNode.prototype);\n    IncludeNode.call(node);\n    node.setProperty('template', template);\n};\nIncludeNode.prototype = {\n    doGenerateCode: function (template) {\n        var templatePath = this.getProperty('template') || this.getAttribute('template');\n        var templateData = this.getProperty('templateData') || this.getProperty('template-data');\n        var resourcePath;\n        var _this = this;\n\n        if (templatePath) {\n            this.removeProperty('template');\n\n            var dataExpression;\n            if (templateData) {\n                dataExpression = templateData;\n            } else {\n                dataExpression = {\n                    toString: function () {\n                        var propParts = [];\n                        \n                        _this.forEachProperty(function (name, value) {\n                            name = name.replace(/-([a-z])/g, function (match, lower) {\n                                return lower.toUpperCase();\n                            });\n                            propParts.push(stringify(name) + ': ' + value);\n                        }, _this);\n\n                        if (_this.hasChildren()) {\n                            propParts.push(stringify('invokeBody') + ': ' + _this.getBodyContentFunctionExpression(template, false));\n                        }\n\n                        return '{' + propParts.join(', ') + '}';\n                    }\n                };\n            }\n            template.include(templatePath, dataExpression);\n        } else if ((resourcePath = this.getAttribute('resource'))) {\n            var isStatic = this.getProperty('static') !== false;\n            if (isStatic) {\n                resourcePath = nodePath.resolve(template.dirname, resourcePath);\n                if (!fs.existsSync(resourcePath)) {\n                    this.addError('Resource not found: ' + resourcePath);\n                    return;\n                }\n                template.write(stringify(fs.readFileSync(resourcePath, {encoding: 'utf8'})));\n            }\n        } else {\n            this.addError('\"template\" or \"resource\" attribute is required');\n        }\n    }\n};\n\nmodule.exports = IncludeNode;","/home/travis/build/npmtest/node-npmtest-raptor-templates/node_modules/raptor-templates/taglibs/core/core-text-transformer.js":"/*\n * Copyright 2011 eBay Software Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n'use strict';\nvar WriteNode = require('./WriteNode');\nvar ScriptletNode = require('./ScriptletNode');\n\nmodule.exports = function transform(node, compiler) {\n    if (node.parentNode && node.parentNode.parseBodyText === false) {\n        return;    //Don't try to parse expressions\n    }\n    var parts = [];\n    compiler.parseExpression(node.text, {\n        text: function (text, escapeXml) {\n            parts.push({\n                text: text,\n                escapeXml: escapeXml\n            });\n        },\n        expression: function (expression, escapeXml) {\n            parts.push({\n                expression: expression,\n                escapeXml: escapeXml\n            });\n        },\n        scriptlet: function (scriptlet) {\n            parts.push({ scriptlet: scriptlet });\n        },\n        error: function (message) {\n            node.addError(message);\n        }\n    });\n    if (parts.length > 0) {\n        var startIndex = 0;\n        if (parts[0].text) {\n            node.setText(parts[0].text);\n            //Update this text node to match first text part and we'll add the remaining\n            node.setEscapeXml(parts[0].escapeXml !== false);\n            startIndex = 1;\n        } else {\n            node.text = '';\n            //The first part is an expression so we'll just zero out this text node\n            startIndex = 0;\n        }\n        var newNodes = [];\n        for (var i = startIndex, part, newNode; i < parts.length; i++) {\n            part = parts[i];\n            newNode = null;\n            if (part.hasOwnProperty('text')) {\n                newNode = compiler.createTextNode(part.text, part.escapeXml !== false);\n                newNode.setTransformerApplied(this);    //We shouldn't reprocess the new text node\n            } else if (part.hasOwnProperty('expression')) {\n                newNode = compiler.createNode(WriteNode, {\n                    expression: part.expression,\n                    escapeXml: part.escapeXml !== false\n                });\n            } else if (part.hasOwnProperty('scriptlet')) {\n                newNode = compiler.createNode(ScriptletNode, part.scriptlet);\n            }\n            if (newNode) {\n                newNode.setPosition(node.getPosition());\n                newNodes.push(newNode);\n            }\n        }\n        if (newNodes.length) {\n            node.parentNode.insertAfter(newNodes, node);\n        }\n    }\n};","/home/travis/build/npmtest/node-npmtest-raptor-templates/node_modules/raptor-templates/taglibs/core/ScriptletNode.js":"/*\n * Copyright 2011 eBay Software Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n'use strict';\nfunction ScriptletNode(code) {\n    ScriptletNode.$super.call(this, 'scriptlet');\n    this.code = code;\n}\nScriptletNode.prototype = {\n    doGenerateCode: function (template) {\n        if (this.code) {\n            template.code(this.code);\n        }\n    },\n    toString: function () {\n        return '{%' + this.code + '%}';\n    }\n};\n\nmodule.exports = ScriptletNode;","/home/travis/build/npmtest/node-npmtest-raptor-templates/node_modules/raptor-templates/taglibs/core/DefNode.js":"/*\n * Copyright 2011 eBay Software Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n'use strict';\nvar funcDefRegExp = /^([A-Za-z_][A-Za-z0-9_]*)(?:\\(((?:[A-Za-z_][A-Za-z0-9_]*,\\s*)*[A-Za-z_][A-Za-z0-9_]*)?\\))?$/;\nfunction DefNode(props) {\n    DefNode.$super.call(this);\n    if (props) {\n        this.setProperties(props);\n    }\n}\nDefNode.prototype = {\n    doGenerateCode: function (template) {\n        var func = this.getProperty('function');\n        if (!func) {\n            this.addError('\"function\" attribute is required');\n            this.generateCodeForChildren(template);\n            return;\n        }\n        func = func.trim();\n        var matches = funcDefRegExp.exec(func);\n        if (matches) {\n            var name = matches[1];\n            var params = matches[2] ? matches[2].split(/\\s*,\\s*/) : [];\n            var definedFunctions = template.getAttribute('core:definedFunctions');\n            if (!definedFunctions) {\n                definedFunctions = template.setAttribute('core:definedFunctions', {});\n            }\n            definedFunctions[name] = {\n                params: params,\n                bodyParam: this.getProperty('bodyParam')\n            };\n        } else {\n            this.addError('Invalid function name of \"' + func + '\"');\n            this.generateCodeForChildren(template);\n            return;\n        }\n\n        if (func.indexOf('(') === -1) {\n            func += '()';\n        }\n        \n        template.statement('function ' + func + ' {').indent(function () {\n            template.line('return __helpers.c(context, function() {').indent(function () {\n                this.generateCodeForChildren(template);\n            }, this).line('});');\n        }, this).line('}');\n    }\n};\n\nmodule.exports = DefNode;","/home/travis/build/npmtest/node-npmtest-raptor-templates/node_modules/raptor-templates/taglibs/core/else-tag-transformer.js":"/*\n * Copyright 2011 eBay Software Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n'use strict';\nmodule.exports = function transform(node, compiler) {\n    var curNode = node.previousSibling;\n    var matchingNode;\n    var IfNode = compiler.getNodeClass('c-if');\n    var ElseIfNode = compiler.getNodeClass('c-else-if');\n    var whitespaceNodes = [];\n    while (curNode) {\n        if (curNode.getNodeClass() === ElseIfNode || curNode.getNodeClass() === IfNode) {\n            matchingNode = curNode;\n            break;\n        } else if (curNode.isTextNode()) {\n            var trimmed = curNode.getText().trim();\n            if (trimmed !== '') {\n                node.addError('Static text \"' + trimmed + '\" is not allowed before ' + node.toString() + ' tag.');\n                return;\n            } else {\n                whitespaceNodes.push(curNode);\n            }\n        } else {\n            node.addError(curNode + ' is not allowed before ' + node.toString() + ' tag.');\n            return;\n        }\n        curNode = curNode.previousSibling;\n    }\n    if (!matchingNode) {\n        node.addError('<c-if> or <c-else-if> node not found immediately before ' + node.toString() + ' tag.');\n        return;\n    }\n    whitespaceNodes.forEach(function (whitespaceNode) {\n        whitespaceNode.parentNode.removeChild(whitespaceNode);\n    });\n    matchingNode.hasElse = true;\n    node.valid = true;\n};","/home/travis/build/npmtest/node-npmtest-raptor-templates/node_modules/raptor-templates/taglibs/core/InvokeNode.js":"/*\n * Copyright 2011 eBay Software Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n'use strict';\nvar forEach = require('raptor-util').forEach;\n\nfunction InvokeNode(props) {\n    InvokeNode.$super.call(this);\n    if (props) {\n        this.setProperties(props);\n    }\n}\n\nInvokeNode.prototype = {\n    doGenerateCode: function (template) {\n        var func = this.getProperty('function');\n        var funcDef;\n        var bodyParam;\n        var definedFunctions = template.getAttribute('core:definedFunctions');\n        if (!func) {\n            this.addError('\"function\" attribute is required');\n            return;\n        }\n        if (func.indexOf('(') === -1) {\n            funcDef = definedFunctions ? definedFunctions[func] : null;\n            var argParts = [];\n            var validParamsLookup = {};\n            var params = [];\n            if (funcDef) {\n                params = funcDef.params || [];\n                bodyParam = funcDef.bodyParam;\n                /*\n                 * Loop over the defined parameters to figure out the names of allowed parameters and add them to a lookup\n                 */\n                forEach(params, function (param) {\n                    validParamsLookup[param] = true;\n                }, this);\n            }\n            var bodyArg = null;\n            if (this.hasChildren()) {\n                if (!funcDef || !funcDef.bodyParam) {\n                    this.addError('Nested content provided when invoking macro \"' + func + '\" but defined macro does not support nested content.');\n                } else {\n                    bodyArg = this.getBodyContentExpression(template, false);\n                }\n            }\n            /*\n             * VALIDATION:\n             * Loop over all of the provided attributes and make sure they are allowed \n             */\n            this.forEachProperty(function (name, value) {\n                if (name === 'function') {\n                    return;\n                }\n                if (!validParamsLookup[name]) {\n                    this.addError('Parameter with name \"' + name + '\" not supported for function with name \"' + func + '\". Allowed parameters: ' + params.join(', '));\n                }\n            }, this);\n            /*\n             * One more pass to build the argument list\n             */\n            forEach(params, function (param) {\n                validParamsLookup[param] = true;\n                if (param === bodyParam) {\n                    argParts.push(bodyArg ? bodyArg : 'undefined');\n                } else {\n                    var arg = this.getAttribute(param);\n                    if (arg == null) {\n                        argParts.push('undefined');\n                    } else {\n                        argParts.push(this.getProperty(param));\n                    }\n                }\n            }, this);\n            template.write(func + '(' + argParts.join(',') + ')');\n        } else {\n            var funcName = func.substring(0, func.indexOf('('));\n            funcDef = definedFunctions ? definedFunctions[funcName] : null;\n            if (funcDef) {\n                template.write(func);\n            } else {\n                template.statement(func + ';\\n');\n            }\n        }\n    }\n};\n\nmodule.exports = InvokeNode;","/home/travis/build/npmtest/node-npmtest-raptor-templates/node_modules/raptor-templates/taglibs/core/RequireNode.js":"/*\n * Copyright 2011 eBay Software Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n'use strict';\nfunction RequireNode(props) {\n    RequireNode.$super.call(this);\n    if (props) {\n        this.setProperties(props);\n    }\n}\nRequireNode.prototype = {\n    javaScriptOnly: true,\n    \n    doGenerateCode: function (template) {\n        var module = this.getProperty('module');\n        var varName = this.getProperty('var');\n\n        if (!module) {\n            this.addError('\"module\" attribute is required');\n        }\n        if (!varName) {\n            this.addError('\"var\" attribute is required');\n        }\n\n        if (module && varName) {\n            template.addStaticVar(varName, 'require(' + module + ')');\n        }\n    }\n};\n\nmodule.exports = RequireNode;","/home/travis/build/npmtest/node-npmtest-raptor-templates/node_modules/raptor-templates/taglibs/core/TemplateNode.js":"/*\n * Copyright 2011 eBay Software Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n'use strict';\nfunction TemplateNode(props) {\n    TemplateNode.$super.call(this, 'c-template');\n    if (props) {\n        this.setProperties(props);\n    }\n}\n\nTemplateNode.nodeType = 'element';\n\nTemplateNode.prototype = {\n    doGenerateCode: function (template) {\n        var params = this.getProperty('params');\n        if (params) {\n            params = params.split(/(?:\\s*,\\s*)|(?:\\s+)/g);\n            params.forEach(function (param) {\n                param = param.trim();\n                if (param.length) {\n                    template.addVar(param, 'data.' + param);\n                }\n            }, this);\n        } else {\n            params = null;\n        }\n        \n        this.generateCodeForChildren(template);\n    }\n};\n\nmodule.exports = TemplateNode;","/home/travis/build/npmtest/node-npmtest-raptor-templates/node_modules/raptor-templates/taglibs/core/VarNode.js":"/*\n * Copyright 2011 eBay Software Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n'use strict';\nvar varNameRegExp = /^[A-Za-z_][A-Za-z0-9_]*$/;\nfunction VarNode(props) {\n    VarNode.$super.call(this);\n    if (props) {\n        this.setProperties(props);\n    }\n}\nVarNode.prototype = {\n    javaScriptOnly: true,\n    doGenerateCode: function (template) {\n        var varName = this.getProperty('name');\n        var value = this.getProperty('value') || this.getProperty('string-value');\n        if (!varName) {\n            this.addError('\"name\" attribute is required');\n        } else if (!varNameRegExp.test(varName)) {\n            this.addError('Invalid variable name of \"' + varName + '\"');\n            varName = null;\n        }\n\n        var isStatic = this.getProperty('static');\n\n        if (varName) {\n            if (isStatic) {\n                template.addStaticVar(varName, value);\n            } else {\n                template.statement('var ' + varName + (value ? '=' + value : '') + ';');    \n            }\n        }\n    }\n};\nmodule.exports = VarNode;","/home/travis/build/npmtest/node-npmtest-raptor-templates/node_modules/raptor-templates/taglibs/html/CommentTag.js":"'use strict';\nmodule.exports = function render(input, context) {\n    context.write('<!--');\n    if (input.invokeBody) {\n        input.invokeBody();\n    }\n    context.write('-->');\n};","/home/travis/build/npmtest/node-npmtest-raptor-templates/node_modules/raptor-templates/taglibs/html/DocTypeNode.js":"/*\n * Copyright 2011 eBay Software Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n'use strict';\n\nfunction DocTypeNode(props) {\n    DocTypeNode.$super.call(this);\n    if (props) {\n        this.setProperties(props);\n    }\n}\nDocTypeNode.nodeType = 'element';\n\nDocTypeNode.prototype = {\n    doGenerateCode: function (template) {\n        var doctype = this.getAttribute('value') || this.getProperty('value');\n        template.text('<!DOCTYPE ');\n        template.parseExpression(doctype, {\n            text: function (text, escapeXml) {\n                template.text(text);\n            },\n            expression: function (expression) {\n                template.write(expression);\n            },\n            error: function (message) {\n                this.addError('Invalid doctype: \"' + doctype + '\". ' + message);\n            }\n        }, this);\n        template.text('>');\n    }\n};\n\nmodule.exports = DocTypeNode;","/home/travis/build/npmtest/node-npmtest-raptor-templates/node_modules/raptor-templates/taglibs/html/html-tag-transformer.js":"/*\n * Copyright 2011 eBay Software Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n'use strict';\nvar DocTypeNode = require('./DocTypeNode');\n\nmodule.exports = function transform(node, compiler) {\n    if (node.isElementNode()) {\n        var options = compiler.options || {};\n        var preserveWhitespace = options.preserveWhitespace || {};\n        var allowSelfClosing = options.allowSelfClosing || {};\n        var startTagOnly = options.startTagOnly || {};\n        var lookupKey = node.namespace ? node.namespace + ':' + node.localName : node.localName;\n\n        if (node.isPreserveWhitespace() == null) {\n            if (preserveWhitespace[lookupKey] === true) {\n                node.setPreserveWhitespace(true);\n            }\n        }\n        if (allowSelfClosing[lookupKey] === true) {\n            node.setAllowSelfClosing(true);\n        }\n        if (compiler.options.xhtml !== true && startTagOnly[lookupKey] === true) {\n            node.setStartTagOnly(true);\n        }\n        \n        if (node.getQName() === 'html' && node.hasAttribute('html-doctype')) {\n            var doctype = node.getAttribute('html-doctype');\n            var docTypeNode = compiler.createNode(DocTypeNode, {\n                    value: doctype,\n                    pos: node.getPosition()\n                });\n            node.parentNode.insertBefore(docTypeNode, node);\n            node.removeAttribute('html-doctype');\n        }\n    }\n};"}